[{"title":"A Summary of Bit Manipulation (reposted from leetcode discussion)","date":"2017-04-01T05:46:11.000Z","path":"2017/04/01/efficiently/","text":"WIKIBit manipulation is the act of algorithmically manipulating bits or other pieces of data shorter than a word. Computer programming tasks that require bit manipulation include low-level device control, error detection and correction algorithms, data compression, encryption algorithms, and optimization. For most other tasks, modern programming languages allow the programmer to work directly with abstractions instead of bits that represent those abstractions. Source code that does bit manipulation makes use of the bitwise operations: AND, OR, XOR, NOT, and bit shifts. Bit manipulation, in some cases, can obviate or reduce the need to loop over a data structure and can give many-fold speed ups, as bit manipulations are processed in parallel, but the code can become more difficult to write and maintain. DETAILSBasicsAt the heart of bit manipulation are the bit-wise operators &amp; (and), | (or), ~ (not) and ^ (exclusive-or, xor) and shift operators a &lt;&lt; b and a &gt;&gt; b. There is no boolean operator counterpart to bitwise exclusive-or, but there is a simple explanation. The exclusive-or operation takes two inputs and returns a 1 if either one or the other of the inputs is a 1, but not if both are. That is, if both inputs are 1 or both inputs are 0, it returns 0. Bitwise exclusive-or, with the operator of a caret, ^, performs the exclusive-or operation on each pair of bits. Exclusive-or is commonly abbreviated XOR. Set union A | B Set intersection A &amp; B Set subtraction A &amp; ~B Set negation ALL_BITS ^ A or ~A Set bit A |= 1 &lt;&lt; bit Clear bit A &amp;= ~(1 &lt;&lt; bit) Test bit (A &amp; 1 &lt;&lt; bit) != 0 Extract last bit A&amp;-A or A&amp;~(A-1) or x^(x&amp;(x-1)) Remove last bit A&amp;(A-1) Get all 1-bits ~0 ExamplesCount the number of ones in the binary representation of the given number 1234567int count_one(int n) &#123; while(n) &#123; n = n&amp;(n-1); count++; &#125; return count;&#125; Is power of four (actually map-checking, iterative and recursive methods can do the same) 1234bool isPowerOfFour(int n) &#123; return !(n&amp;(n-1)) &amp;&amp; (n&amp;0x55555555); //check the 1-bit location;&#125; ^ tricksUse ^ to remove even exactly same numbers and save the odd, or save the distinct bits and remove the same. SUM OF TWO INTEGERSUse ^ and &amp; to add two integers 123int getSum(int a, int b) &#123; return b==0? a:getSum(a^b, (a&amp;b)&lt;&lt;1); //be careful about the terminating condition;&#125; MISSING NUMBERGiven an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array. For example, Given nums = [0, 1, 3] return 2. (Of course, you can do this by math.) 12345678int missingNumber(vector&lt;int&gt;&amp; nums) &#123; int ret = 0; for(int i = 0; i &lt; nums.size(); ++i) &#123; ret ^= i; ret ^= nums[i]; &#125; return ret^=nums.size();&#125; | tricksKeep as many 1-bits as possible Find the largest power of 2 (most significant bit in binary form), which is less than or equal to the given number N. 123456789long largest_power(long N) &#123; //changing all right side bits to 1. N = N | (N&gt;&gt;1); N = N | (N&gt;&gt;2); N = N | (N&gt;&gt;4); N = N | (N&gt;&gt;8); N = N | (N&gt;&gt;16); return (N+1)&gt;&gt;1;&#125; REVERSE BITSReverse bits of a given 32 bits unsigned integer. Solution 123456789uint32_t reverseBits(uint32_t n) &#123; unsigned int mask = 1&lt;&lt;31, res = 0; for(int i = 0; i &lt; 32; ++i) &#123; if(n &amp; 1) res |= mask; mask &gt;&gt;= 1; n &gt;&gt;= 1; &#125; return res;&#125; 123456789uint32_t reverseBits(uint32_t n) &#123; uint32_t mask = 1, ret = 0; for(int i = 0; i &lt; 32; ++i)&#123; ret &lt;&lt;= 1; if(mask &amp; n) ret |= 1; mask &lt;&lt;= 1; &#125; return ret;&#125; &amp; tricksJust selecting certain bits Reversing the bits in integer 12345x = ((x &amp; 0xaaaaaaaa) &gt;&gt; 1) | ((x &amp; 0x55555555) &lt;&lt; 1);x = ((x &amp; 0xcccccccc) &gt;&gt; 2) | ((x &amp; 0x33333333) &lt;&lt; 2);x = ((x &amp; 0xf0f0f0f0) &gt;&gt; 4) | ((x &amp; 0x0f0f0f0f) &lt;&lt; 4);x = ((x &amp; 0xff00ff00) &gt;&gt; 8) | ((x &amp; 0x00ff00ff) &lt;&lt; 8);x = ((x &amp; 0xffff0000) &gt;&gt; 16) | ((x &amp; 0x0000ffff) &lt;&lt; 16); BITWISE AND OF NUMBERS RANGEGiven a range [m, n] where 0 &lt;= m &lt;= n &lt;= 2147483647, return the bitwise AND of all numbers in this range, inclusive. For example, given the range [5, 7], you should return 4. Solution123456789int rangeBitwiseAnd(int m, int n) &#123; int a = 0; while(m != n) &#123; m &gt;&gt;= 1; n &gt;&gt;= 1; a++; &#125; return m&lt;&lt;a; &#125; NUMBER OF 1 BITSWrite a function that takes an unsigned integer and returns the number of ’1’ bits it has (also known as the Hamming weight). Solution1234567891011121314151617int hammingWeight(uint32_t n) &#123; int count = 0; while(n) &#123; n = n&amp;(n-1); count++; &#125; return count;&#125;int hammingWeight(uint32_t n) &#123; ulong mask = 1; int count = 0; for(int i = 0; i &lt; 32; ++i)&#123; //31 will not do, delicate; if(mask &amp; n) count++; mask &lt;&lt;= 1; &#125; return count;&#125; Reference: https://discuss.leetcode.com/topic/50315/a-summary-how-to-use-bit-manipulation-to-solve-problems-easily-and-efficiently","tags":[{"name":"bit manipulation","slug":"bit-manipulation","permalink":"https://xijunlee.github.io/tags/bit-manipulation/"}]},{"title":"sklearn中SVM调参说明及经验总结","date":"2017-03-29T12:47:23.000Z","path":"2017/03/29/sklearn中SVM调参说明及经验总结/","text":"写在前面之前只停留在理论上，没有实际沉下心去调参，实际去做了后，发现调参是个大工程（玄学）。于是这篇来总结一下sklearn中svm的参数说明以及调参经验。方便以后查询和回忆。 常用核函数1.linear核函数: $$K(x_i,x_j)=x_i^Tx_j$$2.polynomial核函数: $$K(x_i,x_j)=(\\gamma x_i^Tx_j + r)^d, d&gt;1$$3.RBF核函数（高斯核函数）: $$K(x_i,x_j)=exp(-\\gamma ||x_i-x_j||^2),\\gamma&gt;0$$4.sigmoid核函数: $$K(x_i,x_j)=tanh(\\gamma x_i^Tx_j + r ), \\gamma&gt;0, r&lt;0$$ sklearn svm 相关参数的官方说明Parameters:C : float, optional (default=1.0). Penalty parameter C of the error term.kernel : string, optional (default=’rbf’). Specifies the kernel type to be used in the algorithm. It must be one of ‘linear’, ‘poly’, ‘rbf’, ‘sigmoid’, ‘precomputed’ or a callable. If none is given, ‘rbf’ will be used. If a callable is given it is used to pre-compute the kernel matrix from data matrices; that matrix should be an array of shape (n_samples, n_samples).degree : int, optional (default=3). Degree of the polynomial kernel function (‘poly’). Ignored by all other kernels.gamma : float, optional (default=’auto’). Kernel coefficient for ‘rbf’, ‘poly’ and ‘sigmoid’. If gamma is ‘auto’ then 1/n_features will be used instead.coef0 : float, optional (default=0.0). Independent term in kernel function. It is only significant in ‘poly’ and ‘sigmoid’.probability : boolean, optional (default=False). Whether to enable probability estimates. This must be enabled prior to calling fit, and will slow down that method.shrinking : boolean, optional (default=True). Whether to use the shrinking heuristic.tol : float, optional (default=1e-3). Tolerance for stopping criterion.cache_size : float, optional. Specify the size of the kernel cache (in MB).class_weight : {dict, ‘balanced’}, optional. Set the parameter C of class i to class_weight[i]C for SVC. If not given, all classes are supposed to have weight one. The “balanced” mode uses the values of y to automatically adjust weights inversely proportional to class frequencies in the input data as n_samples / (n_classes np.bincount(y))verbose : bool, default: False. Enable verbose output. Note that this setting takes advantage of a per-process runtime setting in libsvm that, if enabled, may not work properly in a multithreaded context.max_iter : int, optional (default=-1). Hard limit on iterations within solver, or -1 for no limit.decision_function_shape : ‘ovo’, ‘ovr’ or None, default=None. Whether to return a one-vs-rest (‘ovr’) decision function of shape (n_samples, n_classes) as all other classifiers, or the original one-vs-one (‘ovo’) decision function of libsvm which has shape (n_samples, n_classes * (n_classes - 1) / 2). The default of None will currently behave as ‘ovo’ for backward compatibility and raise a deprecation warning, but will change ‘ovr’ in 0.19.New in version 0.17: decision_function_shape=’ovr’ is recommended.Changed in version 0.17: Deprecated decision_function_shape=’ovo’ and None.random_state : int seed, RandomState instance, or None (default). The seed of the pseudo random number generator to use when shuffling the data for probability estimation. libsvm中参数说明因为sklearn底层是调用libsvm的，因此sklearn中svm参数说明是可以直接参考libsvm中的。 1.linear核函数: $$K(x_i,x_j)=x_i^Tx_j$$2.polynomial核函数: $$K(x_i,x_j)=(\\gamma x_i^Tx_j + r)^d, d&gt;1$$3.RBF核函数（高斯核函数）: $$K(x_i,x_j)=exp(-\\gamma ||x_i-x_j||^2),\\gamma&gt;0$$4.sigmoid核函数: $$K(x_i,x_j)=tanh(\\gamma x_i^Tx_j + r ), \\gamma&gt;0, r&lt;0$$ 首先介绍下与核函数相对应的参数：1）对于线性核函数，没有专门需要设置的参数2）对于多项式核函数，有三个参数。-d用来设置多项式核函数的最高次项次数，也就是公式中的d，默认值是3。-g用来设置核函数中的gamma参数设置，也就是公式中的gamma，默认值是1/k（特征数）。-r用来设置核函数中的coef0，也就是公式中的第二个r，默认值是0。3）对于RBF核函数，有一个参数。-g用来设置核函数中的gamma参数设置，也就是公式中gamma，默认值是1/k（k是特征数）。4）对于sigmoid核函数，有两个参数。-g用来设置核函数中的gamma参数设置，也就是公式中gamma，默认值是1/k（k是特征数）。-r用来设置核函数中的coef0，也就是公式中的第二个r，默认值是0。 具体来说说rbf核函数中C和gamma ： SVM模型有两个非常重要的参数C与gamma。其中 C是惩罚系数，即对误差的宽容度。c越高，说明越不能容忍出现误差,容易过拟合。C越小，容易欠拟合。C过大或过小，泛化能力变差 gamma是选择RBF函数作为kernel后，该函数自带的一个参数。隐含地决定了数据映射到新的特征空间后的分布，gamma越大，支持向量越少，gamma值越小，支持向量越多。支持向量的个数影响训练与预测的速度。 这里面大家需要注意的就是gamma的物理意义，大家提到很多的RBF的幅宽，它会影响每个支持向量对应的高斯的作用范围，从而影响泛化性能。我的理解：如果gamma设的太大，方差会很小，方差很小的高斯分布长得又高又瘦， 会造成只会作用于支持向量样本附近，对于未知样本分类效果很差，存在训练准确率可以很高，(如果让方差无穷小，则理论上，高斯核的SVM可以拟合任何非线性数据，但容易过拟合)而测试准确率不高的可能，就是通常说的过训练；而如果设的过小，则会造成平滑效应太大，无法在训练集上得到特别高的准确率，也会影响测试集的准确率。 此外，可以明确的两个结论是：结论1：样本数目少于特征维度并不一定会导致过拟合，这可以参考余凯老师的这句评论：“这不是原因啊，呵呵。用RBF kernel, 系统的dimension实际上不超过样本数，与特征维数没有一个trivial的关系。” 结论2：RBF核应该可以得到与线性核相近的效果（按照理论，RBF核可以模拟线性核），可能好于线性核，也可能差于，但是，不应该相差太多。当然，很多问题中，比如维度过高，或者样本海量的情况下，大家更倾向于用线性核，因为效果相当，但是在速度和模型大小方面，线性核会有更好的表现。 Reference: http://scikit-learn.org/stable/modules/generated/sklearn.svm.SVC.html#sklearn.svm.SVC http://blog.csdn.net/lqhbupt/article/details/8610443 http://blog.csdn.net/lujiandong1/article/details/46386201","tags":[{"name":"SVM","slug":"SVM","permalink":"https://xijunlee.github.io/tags/SVM/"}]},{"title":"reddit上有趣的SVM图解","date":"2017-03-13T05:26:10.000Z","path":"2017/03/13/reddit上直观有趣的SVM解释/","text":"写在前面这是目前看到过的对SVM的最直观的解释，原题目名还叫作Please explain Support Vector Machines (SVM) like I am a 5 year old。于是，稍微整理下放到博客里。我个人认为，它对SVM中kernel function解释地相当形象。 正文Found this on Reddit r/machinelearning (In related news, there’s a machine learning subreddit. Wow.) Support Vector Machines (warning: Wikipedia dense article alert in previous link!) are learning models used for classification: which individuals in a population belong where? So… how do SVM and the mysterious “kernel” work? The user curious_thoughts asked for an explanation of SVMs like s/he was a five year old. User copperking stepped up to the plate: We have 2 colors of balls on the table that we want to separate. We get a stick and put it on the table, this works pretty well right? Some villain comes and places more balls on the table, it kind of works but one of the balls is on the wrong side and there is probably a better place to put the stick now. SVMs try to put the stick in the best possible place by having as big a gap on either side of the stick as possible. Now when the villain returns the stick is still in a pretty good spot. There is another trick in the SVM toolbox that is even more important. Say the villain has seen how good you are with a stick so he gives you a new challenge. There’s no stick in the world that will let you split those balls well, so what do you do? You flip the table of course! Throwing the balls into the air. Then, with your pro ninja skills, you grab a sheet of paper and slip it between the balls. Now, looking at the balls from where the villain is standing, they balls will look split by some curvy line. Boring adults the call balls data, the stick a classifier, the biggest gap trick optimization, call flipping the table kernelling and the piece of paper a hyperplane.","tags":[{"name":"Support Vector Machine","slug":"Support-Vector-Machine","permalink":"https://xijunlee.github.io/tags/Support-Vector-Machine/"}]},{"title":"GitMemo: Working with Git on Windows","date":"2017-02-21T13:41:38.000Z","path":"2017/02/21/GitMemo-Working-with-Git-on-Windows-repost/","text":"PreambleSetting up Git can be tricky on Windows compared to Linux or Mac, but if you follow the steps in this guide, you should have no problems using Git on Windows. This guide will take you through the steps to install and configure Git and connect it to remote repositories to clone, push, and pull. Choosing a Git distributionThere are two competing Git packages for Windows: a Cygwin-based Git and a version called msysGit. I will describe how to install the msysGit package. I recommend installing msysGit because I’ve found it’s easier to work with than the Cygwin based installation. Installing GitOnce you have downloaded the msysGit executable, double click on it to start the installation wizard. Leave the default directory options. When you get to the “Adjusting your Path environment” setting, select the “Run Git from the Windows Command Prompt” option. Choosing this option will make it easy for you to run Git commands from the Windows Command Prompt (command line) if you choose. Command Prompt is a simple tool, where you can run commands, switch through folders, manage files and it can be ran by selecting RUN… in START menu, and executing cmdcommand. Note : I recommend that you better choose the default options when installing msysGit for saving your time and mind. You will notice that for the rest of this article we will use Git Bash for running Git commands. The Git Bash tool works in the same way as the default Windows’ Command Prompt, but has some special features. With Git Bash you’ll be able to use a number of UNIX command line tools along with access to Git, and we recommend it since it’s often simpler to use than the Windows Command Prompt. You can run it by right clicking your mouse on the desktop, and selecting Git Bash from pop up window. Important note : The most common problems when setting up Git on Windows are related to SSH keys. Git uses SSH keys to securely access your repositories, and in Windows SSH keys are often searched on the wrong path when you try to use Git. If you use an older version of msysGit, you may encounter a step called “Choosing the SSH executables”. If you encounter that dialog, we recommend that you choose the “Use OpenSSH” option. After you have successfully installed Git on Windows, you’ll need to provide secure communication with your Git repositories by creating and installing SSH keys. Installing SSH keys on WindowsTo access your Git repositories you will need to create and install SSH keys. You can do this using OpenSSH and generate SSH keys with ssh-keygen Using OpenSSH and generating SSH keys with ssh-keygenTo communicate with the remote Git repository from your Windows computer, you will need to generate an SSH key pair for that computer. This process requires only a few steps, but you do first need to install msysGit using the full installer as described above. Generating a key pairTo do this you need to run Git Bash, which can be found in your START menu. Run the command: 1ssh-keygen -t rsa -C youremail@xxx.xxx Next, there will be several messages that asks you to set pass phrase. You could keep entering return key to skip these askings. Now that the keys are generated, open the file id_rsa.pub (found in the default location from the previous step) with a text editor. The contents of this file is your new public key. If you copy it to your clipboard, you can add it to your git SSH keys. Your SSH public key should look something like this: 12345ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAyyA8wePstPC69PeuHFtOwyTecByonsHFAjHbVnZ+h0dpomvLZxUtbknNj3+c7MPYKqKBOx9gUKV/diR/mIDqsb405MlrI1kmNR9zbFGYAAwIH/Gxt0Lv5ffwaqsz7cECHBbMojQGEz3IH3twEvDfF6cu5p00QfP0MSmEi/eB+W+h30NGdqLJCziLDlp409jAfXbQm/4Yx7apLvEmkaYSrb5f/pfvYv1FEV1tS8/J7DgdHUAWo6gyGUUSZJgsyHcuJT7v9Tf0xwiFWOWL9WsWXa9fCKqTeYnYJhHlqfinZRnT/+jkz0OZ7YmXo6j4Hyms3RCOqenIX1W6gnIn+eQIkw==Mac Pro Adding your SSH public key to your git SSH keys1.Log your git account in, and click your avatar. Then, click Setting and find SSH and GPG keys. 2.Click New SSH key, copy your SSH public key in Key input area, and give this SSH key name in Title input area. Checking your connectionEnter the following code to check whether you access to github successfully: 1ssh git@github.com You will see: 123The authenticity of host 'github.com (207.97.227.239)' can't be established. RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48. Are you sure you want to continue connecting (yes/no)? Enter Yes, you will see: 1Hi your name! You've successfully authenticated, but GitHub does not provide shell access. If you see above code, that indicates you have accessed github successfully!","tags":[{"name":"git","slug":"git","permalink":"https://xijunlee.github.io/tags/git/"}]},{"title":"爬虫练手(一)：爬下新浪爱问所有问题！","date":"2017-02-16T07:33:43.000Z","path":"2017/02/16/爬虫练手一：爬下新浪爱问所有问题！/","text":"写在前面老早就想写爬虫了，只奈何以前总是空有一颗写爬虫的心。很多事情不可能全部都准备好才动手做，而是在边做的过程中边学。看着大神的博客，学了五天，写了几个小demo，遂准备自己动手从头写一个爬虫来练手。这篇博文不是教程，相当于一个readme文档吧。 爬的对象 – 新浪爱问选择新浪爱问作为爬虫对象的原因如下： 大神博客中虽然有对该网站爬的教程，但是因为网站改版了，大神的正则表达式代码失效，很多读者都在求代码。既然没人来做，那就我来做好了； 这个网站比较简单，不需要密码登录验证，不反爬虫。这对于我这么一个爬虫新手，是相当友好的练手对象。 爬的目标爱问某一个专题下所有问题，以及问题下的最佳答案（当然，有的问题也可能没有最佳答案） 实现我是用python实现的这个爬虫（人生苦短，我用python。实现起来真是高效到没朋友） 需要挖掘的部分 从上图可以看出，我必须要挖出来的有两部分：每一页的链接，每一页的所有问题。进一步延伸，在爬下每一页的某一个问题后，要进入该问题详情页面中将最佳答案的内容爬下来。 使用的库 urllib &amp; urllib2 – 这两个库是用来访问网页获得网页源码的，具体使用方法见最后的代码或者官方文档。 re &amp; bs4 – 这两个库用来解析网页源码，挖出我所需要的每一页的链接，每一页的所有问题 具体实现的几个重要函数一、获得网页源码 123456789101112#传入url，获取该页的代码def getPage(self,pageStr): try: url = self.baseURL + pageStr request = urllib2.Request(url) response = urllib2.urlopen(request) return response except urllib2.URLError, e: if hasattr(e,\"reason\"): print u\"连接新浪爱问失败,错误原因\",e.reason return None 上述代码中，baseURL是新浪爱问的基地址，需要初始化实例的过程中传入，pageStr是待访问页面的定位符。baseURL+pageStr即为页面最终的网址。我之所以这么做，是因为该网站下所有网页都是有一个相同的基地址baseURL，而不同的专题页面都有不同的定位符pageStr。 二、解析网页源码中的链接 1234567891011121314151617181920212223242526def getContent(self): #获得起始页的源码 #page = self.getPage(self.startPage).read().decode(\"utf-8\") page = self.getPage(self.startPage).read() #pdb.set_trace() #获得1-100页的源码 for i in range(1,self.endNum): print (\"正在获得第%d页的源码...\" %(i)) self.file.write(\"第%d页的问题\\n\" %(i)) #解析当前页源码 soup = BeautifulSoup(page,\"lxml\") #获得当前页的地址 current = soup.find(\"a\", string=i) #获得当前页的问题 questions = soup.find_all('div', class_='question-title') #处理当前页的问题 print (\"正在处理第%d页的问题...\" %(i)) self.handleQuestions(questions) #处理完当前页，跳到下一页 page = self.getPage(current['href']).read() self.file.close() 我利用beautiful soup来帮助解析获得当前页的链接，这个需要观察网页源码的代码特征，才能利用beautiful soup完成这一工作。 三、解析网页源码中的问题内容以及可能的最佳答案 前面已经利用beautiful soup提取出网页中的问题，现在进入问题详情页面，利用正则表达式来提取出网页源码中的问题内容和可能的最佳答案。说具题外话虽然是匹配出来了，但是我觉着我对正则表达式的理解还是很浅，还是需要多练。 12345678910111213141516171819202122232425262728293031def handleQuestions(self,questions): #处理questions中的每一个question for question in questions: for a in question.children: aString = str(a).strip() pattern = re.compile('&lt;a href=\"(.*?)\".*?&gt;(.*?)&lt;/a&gt;',re.S) check = re.search(pattern,aString) if check: items = re.findall(pattern,aString) #获得问题详情链接和问题内容 item = items[0] href = item[0] questionStr = item[1] ansPage = self.getPage(href).read() ansStr = self.getAnswer(ansPage) self.file.write(\"Q:\"+questionStr+\"\\n\") self.file.write(\"A:\"+ansStr+\"\\n\\n\") def getAnswer(self,page): pattern = re.compile('&lt;div class=\"good_answer.*?&lt;div&gt;.*?&lt;span&gt;(.*?)&lt;/span&gt;',re.S) check = re.search(pattern,page) ansStr = '' if check: items = re.findall(pattern,page) ansStr = self.formatTool.replace(items[0]) return ansStr 四、格式处理 123456789101112131415161718192021class FormatTool: def __init__(self): self.removeIMG = re.compile('&lt;img.*?&gt;',re.S) self.removeBR = re.compile('&lt;br&gt;|&lt;br/&gt;',re.S) self.removeBP = re.compile(' &#123;7&#125;',re.S) self.removeLink = re.compile('&lt;a.*?&gt;.*?&lt;/a&gt;',re.S) self.removeDIV = re.compile('&lt;div.*?&gt;.*?&lt;/div&gt;',re.S) self.removePre1 = re.compile('&lt;pre&gt;',re.S) self.removePre2 = re.compile('&lt;/pre&gt;',re.S) def replace(self,content): content = re.sub(self.removeBR,\"\\n\",content) content = re.sub(self.removeLink,\"\",content) content = re.sub(self.removeDIV,\"\",content) content = re.sub(self.removePre1,\"\",content) content = re.sub(self.removePre2,\"\",content) return content.strip() 前面利用正则表达式匹配出的问题内容和答案中，可能还会存在一些链接和图片的代码，需要再次利用正则表达式来剔除，使格式变得更好看。 代码以及部分结果我挖到的结果部分展示如下:(完整结果戳这里，虽然应该是没什么卵用) 1234567891011121314151617181920212223242526272829303132333435363738第1页的问题Q:怎样下载真实的宜聚网A:可以去官网、V信或者APP Store。Q:请问深圳超算中心测试云的信息评测主要包括哪些呢？A:主要包括业主方项目验收；基金项目验收；科研项目验收；全流程测试；系统安全检查；系统性能测试Q:宜聚网和钻库网谁更出色A:宜聚网是专注车贷的，所以我觉得它可能好一点，实物抵押安全性高，加上收益也还不错。Q:有人了解现在的一元云购平台吗？那个比较好呢？A:星喜夺宝很好，这是由深圳市星喜夺宝网络科技有限公司注入巨资打造的新型购物平台，实力非常的雄厚，提供的奖品非常的丰富高端。Q: WILO威乐天猫有他们的旗舰店吗？ A:有的有促销活动呢 ...Q:听朋友说vipabc在网上注册就会送很多好东西？真的吗？现在还有这种活动吗？ A:vipabc经常会搞一些这类活动，只要在网上报名，免费试听一节体验课程，就有机会获得各种奖品，让大家一边了解vipabc的教学模式，一边还能获得更多奖品和实惠，一举多得。Q:长城厨电和长城电脑的关系，你们知道吗？A:关系很简单，就是都属于用长城这个民族品牌的国有控股企业，家里的燃气灶就是长城厨电的产品，真的是很好用。 ....Q:Html5 Canvas是做什么的，清除屏幕可以做吗?A:“在粤嵌的学习中，我们需要清除部分或者全部的屏幕，类似于j2me的setcilp函数，在html canvas中有两种方法可以清除屏幕，一种是clearRect和整个屏幕宽度高度技巧。不同的是clearRect可以实现部分的屏幕的清除也可以实现清除全屏的方法，而重设屏幕宽高只能清除部分的屏幕。“ .... 最后还是采用面向对象的编程风格整理了所有实现代码，如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#!/usr/bin/env python# coding=utf-8import urllibimport urllib2import refrom bs4 import BeautifulSoupimport pdbclass IASKSpider: #初始化，传入基地址和开始页 def __init__(self,baseUrl,startPage,endNum): self.baseURL = baseUrl self.startPage = startPage self.formatTool = FormatTool() self.endNum = endNum self.file = open(\"iask_question_and_answer.txt\",'w+') #传入url，获取该页的代码 def getPage(self,pageStr): try: url = self.baseURL + pageStr request = urllib2.Request(url) response = urllib2.urlopen(request) #print response.read() return response except urllib2.URLError, e: if hasattr(e,\"reason\"): print u\"连接新浪爱问失败,错误原因\",e.reason return None def getContent(self): #获得起始页的源码 #page = self.getPage(self.startPage).read().decode(\"utf-8\") page = self.getPage(self.startPage).read() #pdb.set_trace() #获得1-100页的源码 for i in range(1,self.endNum): print (\"正在获得第%d页的源码...\" %(i)) self.file.write(\"第%d页的问题\\n\" %(i)) #解析当前页源码 soup = BeautifulSoup(page,\"lxml\") #获得当前页的地址 current = soup.find(\"a\", string=i) #获得当前页的问题 questions = soup.find_all('div', class_='question-title') #处理当前页的问题 print (\"正在处理第%d页的问题...\" %(i)) self.handleQuestions(questions) #处理完当前页，跳到下一页 page = self.getPage(current['href']).read() self.file.close() def handleQuestions(self,questions): #处理questions中的每一个question for question in questions: for a in question.children: aString = str(a).strip() pattern = re.compile('&lt;a href=\"(.*?)\".*?&gt;(.*?)&lt;/a&gt;',re.S) check = re.search(pattern,aString) if check: items = re.findall(pattern,aString) #获得问题详情链接和问题内容 item = items[0] href = item[0] questionStr = item[1] ansPage = self.getPage(href).read() ansStr = self.getAnswer(ansPage) self.file.write(\"Q:\"+questionStr+\"\\n\") self.file.write(\"A:\"+ansStr+\"\\n\\n\") def getAnswer(self,page): pattern = re.compile('&lt;div class=\"good_answer.*?&lt;div&gt;.*?&lt;span&gt;(.*?)&lt;/span&gt;',re.S) check = re.search(pattern,page) ansStr = '' if check: items = re.findall(pattern,page) ansStr = self.formatTool.replace(items[0]) return ansStr class FormatTool: def __init__(self): self.removeIMG = re.compile('&lt;img.*?&gt;',re.S) self.removeBR = re.compile('&lt;br&gt;|&lt;br/&gt;',re.S) self.removeBP = re.compile(' &#123;7&#125;',re.S) self.removeLink = re.compile('&lt;a.*?&gt;.*?&lt;/a&gt;',re.S) self.removeDIV = re.compile('&lt;div.*?&gt;.*?&lt;/div&gt;',re.S) self.removePre1 = re.compile('&lt;pre&gt;',re.S) self.removePre2 = re.compile('&lt;/pre&gt;',re.S) def replace(self,content): content = re.sub(self.removeBR,\"\\n\",content) content = re.sub(self.removeLink,\"\",content) content = re.sub(self.removeDIV,\"\",content) content = re.sub(self.removePre1,\"\",content) content = re.sub(self.removePre2,\"\",content) return content.strip() if __name__ == '__main__': baseURL = 'http://iask.sina.com.cn' startPage = '/c/74-all-1-new.html' iaskSpider = IASKSpider(baseURL,startPage,101) iaskSpider.getContent()","tags":[{"name":"spider","slug":"spider","permalink":"https://xijunlee.github.io/tags/spider/"}]},{"title":"python虚拟环境安装与使用(转)","date":"2017-02-10T03:15:15.000Z","path":"2017/02/10/python虚拟环境安装与使用/","text":"在开发Python应用程序的时候，系统安装的Python3只有一个版本：3.4。所有第三方的包都会被pip安装到Python3的site-packages目录下。 如果我们要同时开发多个应用程序，那这些应用程序都会共用一个Python，就是安装在系统的Python 3。如果应用A需要jinja 2.7，而应用B需要jinja 2.6怎么办？ 这种情况下，每个应用可能需要各自拥有一套“独立”的Python运行环境。virtualenv就是用来为一个应用创建一套“隔离”的Python运行环境。 首先，我们用pip安装virtualenv： 1$ pip3 install virtualenv 然后，假定我们要开发一个新的项目，需要一套独立的Python运行环境，可以这么做： 第一步，创建目录： 123Mac:~ michael$ mkdir myprojectMac:~ michael$ cd myproject/Mac:myproject michael$ 第二步，创建一个独立的Python运行环境，命名为venv： 123Mac:myproject michael$ virtualenv --no-site-packages venvUsing base prefix '/usr/local/.../Python.framework/Versions/3.4'New python executable in venv/bin/python3.4Also creating executable in venv/bin/pythonInstalling setuptools, pip, wheel...done. 命令virtualenv就可以创建一个独立的Python运行环境，我们还加上了参数--no-site-packages，这样，已经安装到系统Python环境中的所有第三方包都不会复制过来，这样，我们就得到了一个不带任何第三方包的“干净”的Python运行环境。 新建的Python环境被放到当前目录下的venv目录。有了venv这个Python环境，可以用source进入该环境： 12Mac:myproject michael$ source venv/bin/activate(venv)Mac:myproject michael$ 注意到命令提示符变了，有个(venv)前缀，表示当前环境是一个名为venv的Python环境。 下面正常安装各种第三方包，并运行python命令： 12345(venv)Mac:myproject michael$ pip install jinja2...Successfully installed jinja2-2.7.3 markupsafe-0.23(venv)Mac:myproject michael$ python myapp.py... 在venv环境下，用pip安装的包都被安装到venv这个环境下，系统Python环境不受任何影响。也就是说，venv环境是专门针对myproject这个应用创建的。 退出当前的venv环境，使用deactivate命令： 12(venv)Mac:myproject michael$ deactivate Mac:myproject michael$ 此时就回到了正常的环境，现在pip或python均是在系统Python环境下执行。 完全可以针对每个应用创建独立的Python运行环境，这样就可以对每个应用的Python环境进行隔离。 virtualenv是如何创建“独立”的Python运行环境的呢？原理很简单，就是把系统Python复制一份到virtualenv的环境，用命令source venv/bin/activate进入一个virtualenv环境时，virtualenv会修改相关环境变量，让命令python和pip均指向当前的virtualenv环境。 小结virtualenv为应用提供了隔离的Python运行环境，解决了不同应用间多版本的冲突问题。","tags":[{"name":"python virtual environment","slug":"python-virtual-environment","permalink":"https://xijunlee.github.io/tags/python-virtual-environment/"}]},{"title":"linux下杀死进程（kill）的N种方法(转)","date":"2017-02-05T12:39:52.000Z","path":"2017/02/05/linux下杀死进程（kill）的N种方法/","text":"首先说明这是转载的，作为笔记整理成下文。 常规篇：首先，用ps查看进程，方法如下： 1$ ps -ef 123456789……smx 1822 1 0 11:38 ? 00:00:49 gnome-terminalsmx 1823 1822 0 11:38 ? 00:00:00 gnome-pty-helpersmx 1824 1822 0 11:38 pts/0 00:00:02 bashsmx 1827 1 4 11:38 ? 00:26:28 /usr/lib/firefox-3.6.18/firefox-binsmx 1857 1822 0 11:38 pts/1 00:00:00 bashsmx 1880 1619 0 11:38 ? 00:00:00 update-notifier……smx 11946 1824 0 21:41 pts/0 00:00:00 ps -ef 或者： 1$ ps -aux 12345678910……smx 1822 0.1 0.8 58484 18152 ? Sl 11:38 0:49 gnome-terminalsmx 1823 0.0 0.0 1988 712 ? S 11:38 0:00 gnome-pty-helpersmx 1824 0.0 0.1 6820 3776 pts/0 Ss 11:38 0:02 bashsmx 1827 4.3 5.8 398196 119568 ? Sl 11:38 26:13 /usr/lib/firefox-3.6.18/firefox-binsmx 1857 0.0 0.1 6688 3644 pts/1 Ss 11:38 0:00 bashsmx 1880 0.0 0.6 41536 12620 ? S 11:38 0:00 update-notifier……smx 11953 0.0 0.0 2716 1064 pts/0 R+ 21:42 0:00 ps -aux 此时如果我想杀了火狐的进程就在终端输入： 1$ kill -s 9 1827 其中-s 9 制定了传递给进程的信号是９，即强制、尽快终止进程。 1827则是上面ps查到的火狐的PID。 简单吧，但有个问题，进程少了则无所谓，进程多了，就会觉得痛苦了，无论是ps -ef 还是ps -aux，每次都要在一大串进程信息里面查找到要杀的进程，看的眼都花了。 进阶篇：改进１：把ps的查询结果通过管道给grep查找包含特定字符串的进程。管道符“|”用来隔开两个命令，管道符左边命令的输出会作为管道符右边命令的输入。 123$ ps -ef | grep firefoxsmx 1827 1 4 11:38 ? 00:27:33 /usr/lib/firefox-3.6.18/firefox-binsmx 12029 1824 0 21:54 pts/0 00:00:00 grep --color=auto firefox 这次就清爽了。然后就是 1$kill -s 9 1827 还是嫌打字多？ 改进２——使用pgrep：一看到pgrep首先会想到什么？没错，grep！pgrep的p表明了这个命令是专门用于进程查询的grep。 12$ pgrep firefox1827 看到了什么？没错火狐的PID，接下来又要打字了： 1$kill -s 9 1827 改进３——使用pidof：看到pidof想到啥？没错pid of xx，字面翻译过来就是 xx的PID。 12$ pidof firefox-bin1827 和pgrep相比稍显不足的是，pidof必须给出进程的全名。然后就是老生常谈： 1$kill -s 9 1827 无论使用ps 然后慢慢查找进程PID 还是用grep查找包含相应字符串的进程，亦或者用pgrep直接查找包含相应字符串的进程ＰＩＤ，然后手动输入给ｋｉｌｌ杀掉，都稍显麻烦。有没有更方便的方法？有！ 改进４：1$ps -ef | grep firefox | grep -v grep | cut -c 9-15 | xargs kill -s 9 说明： grep firefox的输出结果是，所有含有关键字firefox的进程。 grep -v grep是在列出的进程中去除含有关键字grep的进程。 cut -c 9-15是截取输入行的第9个字符到第15个字符，而这正好是进程号PID。 xargs kill -s 9中的xargs命令是用来把前面命令的输出结果（PID）作为kill -s 9命令的参数，并执行该命令。kill -s 9会强行杀掉指定进程。 难道你不想抱怨点什么？没错太长了 改进５：知道pgrep和pidof两个命令，干嘛还要打那么长一串！ 1$ pgrep firefox | xargs kill -s 9 改进６：12$ ps -ef | grep firefox | awk '&#123;print $2&#125;' | xargs kill -9kill: No such process 有一个比较郁闷的地方，进程已经正确找到并且终止了，但是执行完却提示找不到进程。 其中awk &#39;{print $2}&#39; 的作用就是打印（print）出第二列的内容。根据常规篇，可以知道ps输出的第二列正好是PID。就把进程相应的PID通过xargs传递给kill作参数，杀掉对应的进程。 改进７：难道每次都要调用xargs把PID传递给kill？答案是否定的： 1$kill -s 9 `ps -aux | grep firefox | awk '&#123;print $2&#125;'` 改进８：没错，命令依然有点长，换成pgrep。 1$kill -s 9 `pgrep firefox` 改进9——pkill：看到pkill想到了什么？没错pgrep和kill！pkill＝pgrep+kill。 1$pkill -９ firefox 说明：”-9” 即发送的信号是9，pkill与kill在这点的差别是：pkill无须 “ｓ”，终止信号等级直接跟在 “-“ 后面。之前我一直以为是 “-s 9”，结果每次运行都无法终止进程。 改进10——killall：killall和pkill是相似的,不过如果给出的进程名不完整，killall会报错。pkill或者pgrep只要给出进程名的一部分就可以终止进程。 1$killall -9 firefox","tags":[{"name":"linux","slug":"linux","permalink":"https://xijunlee.github.io/tags/linux/"}]},{"title":"2016年度总结","date":"2017-01-24T08:06:28.000Z","path":"2017/01/24/2016年度总结/","text":"写在前面本来该篇应该在2017-1-1写出来的，但那时和高中老友在杭州玩😂，回上海后也忘了这茬，所以拖到了现在。虽然现在已经公历2017-1-24，但是标题还是取成“2016年度总结”，因为从农历看的话，现在还没有到2017嘛。之前还从未写过年度总结，所以这篇2016年度总结顺带也总结一下2015。之所以想写年度总结，其实也是受到师兄师姐的启发，梳理和盘点一下，发现一年下来还真是没做什么事情，以此激励自己明年好好把握时间。 2015：转变2015年，可以用“转变”二字来形容。一是从本科顺利毕业了，开始了研究生生涯；二是从广州来到了上海；三是从数学专业转到了软件工程专业。换学校，换专业，整个人的思维也跟着变了。 2015上半年，得知自己保研后，就有一种茫然感，觉着人生暂时地失去了一个清晰的追逐目标。所以大四上学期一直到开始做毕设之前，没事就一个人跑到图书馆里看闲书或者在广州城里闲逛拍照。（当时我居然没出去旅游？突然想起来了，当时大家的时间都不太同步，就我比较闲）大四下学期开始后，就和大家一直在打LOL。LOL打的不少，但是发现自己确实没天赋，依旧那么菜。然后，就按部就班的做毕设，拍毕业照，毕业。没有大家那种离开校园的特别伤感。一是觉得自己还要待在校园三年时光，二是觉得现在交通这么发达，想见面还是挺容易的，关键是你有心。 2015年下半年：毕业到研究生正式入学之间还有将近一个半月假期，没有响应导师的搬砖号召，在家里瘫了一个多月。接着九月份就开学了，来到了上海，一座我很有好感的城市，虽然父辈们总是黑它排外等。在交大，开学头一个月倒是一门课都没有，留给学生和老师处理各种杂事，对，这个月就是各种杂事，我也不想絮叨了，主要说两个事。首先，导师之前分配了一个科研任务，要在十月底交paper，大四倒是写了个初稿，但集群上的大实验还没有做，但那时候我连Linux都没用过😓。其次，上了一门坑爹课——高级软件工程，在这门课上接了一个坑爹的项目Gogou（这个项目就是开发一个同时支持Android和iOS的代购平台，我主要负责iOS前端设计）。这两个事情可谓是我研一一年的主旋律。结果是，前者，paper被拒了一年（其实也就是被拒稿三次）。后者，这个项目写了我整整一年时间。不过，忙归忙，坑归坑，我的coding能力和团队协作能力确实有很大提高，毕竟本科没写过这么大项目，掌握了一些程序猿必须掌握的工具（github,Linux Shell）以及一些iOS开发知识。其次，英语水平也有了一定的提高，一年多下来读了不少paper。 其实这一年，我的“转变”很是被动，主要是因为大四那段时间太过放松，没有及时做好规划。导致在新环境中有点措手不及。所以，开始慢慢培养自己未雨绸缪的意识。首先说说城市的转变。从广州到上海，一线城市在很多方面都具有工业时代的标准化气息，二者有很多地方极其相似，上海比广州可能更加现代化一些，不多说了。但是，在我眼中，两个城市最大的差别就是生活节奏了。广州，虽然也是一线大城市，但是其骨子里有一种享受生活的慢节奏，从其早茶文化中可见一斑。而上海，节奏明显快了很多。虽然，还没上班，但是在校园里，在地铁站中，总是感受到大家匆忙的脚步。其余的方面，还有待我慢慢体会。再说说思维的转变，从理科思维转变到工科思维。记得大一第一次上数学分析课时，刘老师就讲过：“我们数学系的学生，学四年下来，学会的最有价值的就是数学思维，这个东西可以应用到生活中各个方面去，所以我们数学系的学生活跃在各行各业……” 当时，我就不以为然，尤其是数学思维这个东西，我是一点都不信的。但是当我在数学系浸淫了四年，从数学系转到了软件工程这个工科专业后，我从与工科科班出身的人的共事中发现：人和人的思维方式确实差别很大。比如去解决一个从未遇到的问题时，以前的我（理科思维）：我会从头开始去了解这个问题-&gt;查找类似问题的解决方式-&gt;比较和学习所有的方式方法-&gt;着手解决问题本身-&gt;done。而现在的我（工科思维）:了解问题本身-&gt;找到一种解决类似问题的方法-&gt;学习并掌握这种方法，应用它来解决问题-&gt;如果问题没有得到很好的解决，再回到第二步，寻找其他的方法-&gt;不断修正方法，直到解决问题。 2016：变强虽然说是顺带总结一下2015，但是转变的过程让我思考了很多，所以“顺带”写得有点多了。经过一学期的转变和适应后，科研和项目也开始轻车熟路，做得越来越得心应手了。我由衷地觉得在适应了环境后，做很多事情都更有效率了，因此我给2016这一年总结为“变强”。下面就以流水账的形式盘点一下我的2016。 日常1月，研一上学期学期末。高级软件工程课程答辩，谢沈阿姨手下留情，让我们项目组顺利通过。这门课程占据了我整个研一上学期60%可能还多的时间，从一个从未接触过iOS开发的小白到能写出一个还像样子的APP（尽管离投入市场有很大距离），我觉着我还是学到不少东西。虽说只是门硕士课程，但是软件开发的基本流程大概是走了一遍，最大收获就是让我明白：我以后肯定不会从事软件开发的工作（其实是不想做纯coding这种重复劳动，而是想做偏分析和市场的数据挖掘工作）。原本，我以为课程项目的代码可以直接当作最后项目的代码交给甲方了事，但是导师跟我们说不行，需要两套代码分开。但是，当时我工程经验不足，很多代码写的可移植性太差。于是，我们相当于需要再从头开始写，还好已经有经验了，但是很多都是重复性工作，让我没有了先前学习的快感。 2月，回家。照常的聚会、吃饭、走亲戚、过年，在家稍微看了下鸟叔的Linux入门书籍，同时还在继续写Gogou的项目代码。 3月，返校，开始研一下学期。照例，开学头一个月都是用来处理选课等杂事。继续写项目代码。 4月，开始应付各种课程。第一次参加志愿者活动，和室友一起去为上海半程国际马拉松发海绵和冰块。哦对了，一个很重要的变化是从这个月开始了规律的健身。（研一上学期忙的飞起，连打球的次数都屈指可数。虽然这个学期仍然要写项目代码，但很多东西都轻车熟路，就没那么大压力了。在Coach Hong的带领下，开始了健身事业。）继续写项目代码。 5月，论文第二次被拒稿，根据review修改论文，投下一个会议。完成第一个专利的撰写。应付各种课程及其作业。继续写项目代码。 6月，应付各种期末考试，全部都顺利通过，毕业的两座大山翻过一座。成功搭建起Hadoop集群。跑到五角场见高中老友星哥哥（他从长沙到上海出差），虽一年难得见一次，但每次见面都能聊地很开心。继续写项目代码。 7月，开始自学经济学知识。和本科同学们跑去舟山旅游，虽然说是去旅游，但不幸那几天刚好刮台风，再加上妹子们对于Airbnb上租到的房子的一脸花痴样，于是一行七人在舟山的房子里宅了3天。开始构思第二篇论文的思路以及实验。继续写项目代码。 8月，做论文的实验。继续写项目代码。中间回家了两周，参加了高中好友斓哥的婚礼。话说，他是我们同龄人第一个结婚的男人，也是我第一次成为婚礼摄像大哥担当。很开心，见到了很多高中同学。 9月，学习sklearn。第一篇论文又被拒稿，根据review修改论文，投下一个期刊。啊，Gogou项目终于结束了，有一种阶段性胜利的错觉。 10月，十一，罗威林跑来上海玩，因为没买到五月天演唱会的票，于是去隔壁听了Ke$ha的演唱会，很嗨。带着罗威林和五爷大萱面基。继续写项目代码。继续做第二篇论文的实验。 11月，完成第二篇专利的撰写。思考论文思路，开始撰写第二篇论文。在做第二篇论文的过程中，开始思忖到底要不要继续读博。跟着实验室到江西婺源旅游。 12月，完成第二篇论文的撰写，投稿ICDCS。投完论文后，开始划水了。复习机器学习知识。博客迁移到Octopress（该版本的前身）。开始看auction理论，为第三篇论文做准备。 1月，和罗威林跑到杭州找中哥玩耍。去江苏靖江，参加徐宇婚礼，第二次婚礼摄像大哥担当。实验室年会，年会摄像大哥担当。这个月就比较划水了，因为后半个月回家了😓。 娱乐消遣“一个脱离了高级趣味的无聊男人”，这是目前我对自己的定位。我在学校生活的主旋律就是paper和项目，周末也不大想出门，因为我在闵行，进个城花在路上的时间就有两三个小时😂。出门玩一趟（除开吃吃吃），我还是觉得宅在屋子里看书和运动最舒服。业余时间的消遣主要就是健身、篮球和电影，偶尔拍拍照和游泳。下图是我这一年娱乐消遣的频次统计。 健身，现在确实成了业余时间的最大爱好。其实去健身房还是蛮枯燥的，但幸好有一批志同道合的肌友陪着我，没有他们的督促和激励，我想我也坚持不下来。同时，也跟他们学到不少科学健身的知识。但是，仍然觉得自己的肌肉长得很慢，特别是胸肌长得没有咬肌快。从上图可以看到，刚开始时我健身热情很高，几乎一周去个三四次，后面的次数就没那么多了，特别回家的两个月（回家就是过猪一般的生活）。到了下半年，进入写paper的攻坚期，去健身房的次数也少了，因为觉得写论文太累，不想分散精力去健身了。事后，我觉得不要给自己找借口，很多事情不是你做不到，而是内心怠惰或害怕困难而不去做，希望2017年能将每月健身次数保持在12次以上。 篮球，其实每周最开心的就是能打一到两次篮球，这个真的是从小学一直玩到现在的运动。科比退役了，NBA看得没有以前多了，但是打球的热情和那种快乐还是和以前一样。或许，篮球是我最不需要坚持的运动，因为热爱就会自发地去玩。健身也给打球带了额外的好处，比如核心力量和上肢力量的提高，现在做很多动作都更加游刃有余，同时肌肉的增强也降低了受伤的风险。希望2017年，非惯用手能更加熟练。 电影，看得越来越少，特别是来上海后。感觉现在过了看特效电影的年纪，记得看《神奇动物在哪里》、《奇异博士》、《星战》我都睡着了，因为剧情太简单了，全都是一个套路。现在更喜欢看剧情复杂或者讽刺电影，《驴得水》、《比利林恩的中场故事》就给我留下很深的印象。多说一句，过去一年闲暇时间还补或追了几部电视剧，题材广泛，如《来自星星的你》、《琅琊榜》、《余罪》、《行尸走肉》、《权力的游戏》、《西部世界》、《好先生》、《黑镜》、《逃避虽可耻但有用》、《Legal High》（我居然看了这么多……）。再多说一句，现在收听或收看的知识性节目，从《罗辑思维》《晓松奇谈（2017停播）》增加了《锵锵三人行》，很喜欢窦文涛这种揣着明白装糊涂的风骚中年大叔。 阅读本科时期，阅读量仅限于专业书籍，因为觉得看闲书浪费时间，保研了后才开始看闲书。其实，这又是给自己找理由。平时，一个人安静下来会胡思乱想，有时候会搞到心情抑郁。后面把这些时间都拿来看书，就立马治好了这种中二病。统计了下最近一年半看过的纸质书和Kindle电纸书（除掉专业书籍）： 《浪潮之巅》（上下册）、《数学之美》、《三体》（1，2，3）、《单恋》、《解忧杂货店》、《历史的教训》、《美国种族简史》、《欧洲极简史》、《枪炮、病菌与钢铁》、《为奴十二年》、《嫌疑人X的献身》、《中国震撼》、《微观经济学原理》 总共读了才16本书，月均读书量不超过一本……从上可看出，我一如既往地喜欢读历史类书籍。现在开始涉猎经济学知识，尝试着以经济学思维来看待很多事物，讲究回报率。希望2017年每个月至少读完一本书，涉猎更加广泛。 图说2015&amp;2016一张图结束流水账盘点： 2017：期望2015和2016都过去了，之前总认为计划赶不上变化，所以从来没有对未来一年的规划。但是规划并不是都要实现，只是让人能保持一个大方向不至于偏离太多。那么，我就给自己的2017许下那么些期待： 只求中一篇paper（同时也是毕业要求） 每周去健身房三次或以上（希望我的胸从a cup涨到b cup） 每月至少阅读一本书 能找到一份好实习（数据挖掘相关） 找到女朋友（现在爸妈居然在催了，其实我也想啊，但是找到那么个合适的不是这么容易） 左手能熟练运球，能上篮 去霓虹国旅游 世界和平","tags":[{"name":"dairy","slug":"dairy","permalink":"https://xijunlee.github.io/tags/dairy/"}]},{"title":"又从octopress迁移到hexo了……","date":"2017-01-15T08:59:32.000Z","path":"2017/01/15/又从octopress迁移到hexo了……/","text":"之前说好的迁移到octopress后就再也不折腾了，才不到一个月，又被打脸了。这次迁移的目的主要是octopress中的一些bug实在是fix不了（本来就不熟悉前端，也不喜欢写前端）。于是，在上次心动后花了一个下午来把整个博客迁移到hexo框架下。hexo较之octopress更新，而后者现在已经没人维护了，并且hexo是台湾人写的，有大量国人在维护和设计主题，对中文的支持更好。推荐以后想入坑（并且不熟悉前端的），就直接上hexo吧。 已解决的问题目前，在hexo框架下，已经fix的bug有： 日志分享 翻页功能 仍存在的问题 但是mathjax的公式渲染还是有些问题，不知道是不是文档中公式太多问题造成的。留待日后慢慢解决。 关于主题和界面首先，我对前端那一套不熟也不感兴趣。其次，我写博客的目的就是想总结学习知识的思路以及记录些生活琐事。基于以上两点，我不想花太多时间自己diy主题。找了一堆主题试，最后还是采用了yilia这个主题，主要是其提供的功能很健全（比如分享，评论等），并且也比较符合我的审美（但是我最想要的还是一款全黑的）。 希望以后坚持下来！ 以上","tags":[{"name":"dairy","slug":"dairy","permalink":"https://xijunlee.github.io/tags/dairy/"}]},{"title":"常见拍卖机制与模型总结","date":"2017-01-03T08:33:34.000Z","path":"2017/01/03/2017-01-03-chang-jian-pai-mai-ji-zhi-yu-mo-xing-zong-jie/","text":"写在前面的话最近在为下一篇论文做背景知识的调研，两周以来都在读auction的基本理论和概念，本篇就用来总结一下常见的拍卖机制和模型。关于拍卖的理论研究着实复杂，本文只是做一个简单的总结，不涉及过多的数学证明及讨论。 四种基本的拍卖机制增加拍卖（英国式）为简单起见，先考虑拍卖一件物品。在增价拍卖机制下，价格不断上升，直到只剩下一个竞标者为止。一般是由专业拍卖人员叫价，竞标者举手应价，因此也被称为无声拍卖;也可以由竞标 者自己口头提出愿意接受的价格，这叫做有声拍卖;或是大家通过个人电脑输入价格(历史报价都是公开的)。这是用得最多的一种拍卖机制，特别是专业拍卖行均采用这种方式。世界上最古老，最大的两家专业拍卖行，索士比(Sotheby’s)和克里斯蒂(Christie’s)，都起源于英国伦敦，因此，这种增价拍卖方式常被称为英国式拍卖。 减价拍卖（荷兰式）减价拍卖刚好相反，卖家首先从很高的价格开始叫卖，如果没有人愿意出价，卖家由此价格按照事先规定的速度连续减价，直到有第一个人站出来接受卖家的报价。那么该该买家获得拍品。虽然是减价叫卖，但仍然是价高者得。在荷兰，人们常用这种机制来拍卖鲜花，因此称之为荷兰式叫卖。 第一价格拍卖每个竞标者在规定时间内，独立地向拍卖人提交标书，标明自己愿意出的价格，因此看不到其他竞标者的出价，再由拍卖人在约定的时间，邀请所有竞标者到场当众开标，出价最高者赢得物品，并付他自己的报价，因此第一价格拍卖也被称为高价拍卖，亦称招标拍卖或邮递拍卖。 第二价格拍卖与第一价格拍卖类似，在第二价格拍卖机制下，拍品仍然是归报价最高者，但成交价等于各买家中出的第二高报价。此方式在实际中用得不多，但有很好的理论性质。这一机制最先由经济学家维克瑞(William Vickrey)在1961年提出。 在每一种拍卖中，如出现几个人同时报得最高价，那么卖家就会在他们中随机挑选一个人作为赢家。此外，卖家通常还会增加两种限制。一种设定保留价（底价），另一种是收取参加拍卖的费用。在第一价格或第二价格拍卖机制下，竞标者的出价必须高于或等于保留价，否则不能成交。值得注意的是，在第二价格拍卖中，如果只有一个竞标者出价，而且高于保留价，那么他赢得并且支付保留价即可。在增价和减价拍卖中，保留价有着同样的作用。卖方在拍卖开始之前公开保留价，或者密封保留价。此外，卖方通常会要求感兴趣参加竞标的买方支付一定的费用才可以参与竞标。 三种拍卖的基本经济模型独立私有价值模型假设此时有一个卖家，他想卖掉一件物品，他对此物品的估价为$v_0$,这是公开的信息。有$n$个买方对此物品感兴趣，让$v_i$表示第i个买家对该物品的估价。现在作如下假定： 1.(私有价值)：对买方$i$来说，只有他自己知道$v_i$的大小，卖方及其他卖方不知道$v_i$的大小。但是他们会认为$v_i$是分布在$[a,z]$区间上的一个随机变量，并知道其概率分布函数$F_i(v_i)$和密度函数$f_i(v_i)$，其中$0 \\leq a &lt; z$。 2.(独立性)：总体来说，买家们的估价$v_1,v_2,…,v_n$是独立的。即它们的联合分布函数为: $$F(v_1,v_2,…,v_n)=F_1(v_1)F_2(V_2)…F_n(v_n)$$ 3.(对称性)：这些概率分布函数完全相同，即$\\forall i,j=1,2,…,n$和$\\forall v\\in[a,z]$: $$F_i(v)=F_j(v)=F(v)$$ 4.(风险中性)：每个买方的目标是最大化他的期望收益。 5.(非合作行为)：所有买方独立决定自己的竞价策略，不存在任何具有约束力的合作性协议。 所有这些假定中描述的知识，对买卖双方均属共同知识(common knowledge)。比如说，对于任意一个买家$i$，其他人猜测i的估价$v_i$是分布在$[a,z]$区间上的随机变量，并服从概率分布$F_i(v_i)$等等。对这种环境的描述称为对称独立私有价值(Symmetric Independent Private Value)模型，简称为SIPV模型。如果对称性假设不满足时，即各买家的估价分布函数不一致时，此时模型退化为更一般的独立私有价值(Independent Private Value)模型，简称为IPV模型。IPV模型描述了另外一种情况，即当每个买家对拍品有不同的偏好，而且不受别人偏好影响。 共同价值模型另一种极端情况可以用共同价值(Common Value)模型来描述，简称CV模型。对每个人来说，拍品都会有一个共同价值$v$，但卖家和买家都不知道$v$的大小，但他们每个人都有自己的估价$xi$。现作如下假定：共同价值$v$是一个服从概率分布$G(v)$和密度函数$g(v)$的随机变量，$v\\in [v{min},v_{max}]$。每个人的私人估价$x_i$服从$[a,z]$上的条件分布$H_i(x_i|v)$。 在最简单的情况下，我们可以将买家报价$x_i$表示成： $$ x_i=v+\\varepsilon_i $$ 其中$\\varepsilon_i$表示第i个人估价过程中的误差，假定其平均误差为零。 关联价值模型上述两种模型是理想的极端情况，但在现实生活中往往不会出现。有一种更具一般性的模型，能更适当地描述拍卖时间中参与人所处的环境，称为关联价值(Affiliated Value)模型。 第i个买方对拍品的真实价值$v_i$可能取决于所有买方的私人信息$x=(x_1,x_2,…,x_n)$以及其他共同的不确定因素$s=(s_1,s_2,…,s_k)$: $$ v_i=u(s,xi,x{-i}) $$ 其中向量$x_{-i}$表示$(x_1,x_2,…,x_n)$中去掉$x_i$。随机变量$x$和$s$呈现某种关联性，而且每个竞标者的真实价值$v_i$随$(s,xi,x{-i})$中的任何一个变量的增加而增加。 比较而言，关联价值模型对现实更有指导意义，而独立价值模型和共同价值模型是其的特殊情况。","tags":[{"name":"auction","slug":"auction","permalink":"https://xijunlee.github.io/tags/auction/"}]},{"title":"泊松分布与指数分布的重新理解","date":"2016-12-28T03:01:20.000Z","path":"2016/12/28/2016-12-28-bo-song-fen-bu-yu-zhi-shu-fen-bu-de-zhong-xin-li-jie/","text":"写在前面的话组会上有人提到了几种概率分布，当时我听到的感觉就是“啊，我每一个都听过，也学过，但是都忘记了细节😭”。于是，会后又跑去wiki了一番，回忆了以前概率课上学的东西。记得当时学概率分布时，有几种分布是真的无法理解（至少在当时的思维下，我感觉是没有理解的），而且做题时常常陷入一种局部思维，把几种分布搞混淆。过了一两年，重新来看以前学过的东西，发现顿时有了更深的理解（我也不知道为什么，可能这就是所谓的“书读百遍其义自见”，但是也不是读一百遍就一定能懂，我觉得当时我把概念背了很熟，但有些还是不能很好地理解。 所以，现在重新整理下以前似懂非懂或者没注意的概念。 随机变量如果说要举出在概率论中出现频次最高的术语，随机变量绝对是位列三甲的。但是一个出现频次这么高的术语，而且也是概率论这门课一上来老师就强调的概念，我对其的理解却是很肤浅的。 从初等概率论出发。 如果$X$指定概率空间$S$中每一个事件$e$都有一个实数$X(e)$，同时针对每一个实数$r$都有一个事件集合$A_r$与其相对应，其中$A_r={e:X(e)\\leq r}$，那么$X$被称为随机变量。 – wikipedia 从上面的定义可以看到，随机变量其实不是一个变量，而是一个函数，是将概率空间$S$中每一个事件$e$映射到一个实数$r$上的函数。如下图所示： 举个栗子随机投掷两个骰子，那么整个样本空间可以由36个元素组成： $$S={(i,j)|i=1,…,6;j=1,…,6}$$ 很明显这里可以构成多个随机变量。比如随机变量$X$（投掷后两个骰子的点数之和）或者$Y$（投掷后两个骰子的点数之差），随机变量$X$可以有11个整数值，而随机变量$Y$只有6个。 $$X(i,j):=i+j,x=2,3,…,12$$ $$Y(i,j):=|i-j|,y=0,1,2,3,4,5.$$ 从上面的这个例子可以看到，随机变量们将原样本空间中的事件映射到了整数空间。 下面就正式进入正题来讲下我对泊松分布和指数分布的重新理解。因为其他几个分布还比较简单易懂，而泊松分布和指数分布不好懂而且它们也相似，故单独挑这两个出来。 泊松分布 Poisson分布，是一种统计与概率论中常见的离散概率分布，由法国数学家Siméon-Denis Poisson在1838年发表。其适合于描述单位时间内随机事件发生的次数的概率分布。如某一服务设施在一定时间内受到的服务请求的次数，电话交换机接到呼叫的次数、汽车站台的候客人数、机器出现的故障数、自然灾害发生的次数、DNA序列的变异数、放射性原子核的衰变数、激光的光子数分布等等。 –wikipedia 泊松分布的概率质量函数： $$P(X=k)=\\frac{e^{-\\lambda}\\lambda^k}{k!}$$ 泊松分布的参数$\\lambda$是单位时间（或单位面积）内随机事件的平均发生率。 在概率论中，概率质量函数（probability mass function，简写为pmf）是离散随机变量在各特定取值上的概率。概率质量函数和概率密度函数不同之处在于：概率质量函数是对离散随机变量定义的，本身代表该值的概率；概率密度函数是对连续随机变量定义的，本身不是概率，只有对连续随机变量的概率密度函数在某区间内进行积分后才是概率。 泊松分布的累积分布函数: $$P(X\\leq k)=e^{-\\lambda}\\sum_{i=0}^{k}\\frac{\\lambda_i}{i!}$$ 下面分别给出其概率质量函数和累积分布函数的图像： 对着上述图像解释，每个点的意义就是单位时间或面积内随机事件发生k次的概率。 对着上述图像解释，每个点的意义就是单位时间或面积内随机事件发生次数小于等于k次的概率。 指数分布泊松分布，我觉得相对来说还好理解一些。而指数分布就有点那么绕了，不过我觉得结合其概率密度函数图和累积分布函数图来看，就好理解一些了。 在概率论和统计学中，指数分配（Exponential distribution）是一种连续概率分布。指数分配可以用来表示独立随机事件发生的时间间隔，比如旅客进入机场的时间间隔、打进客服中心电话的时间间隔、中文维基百科新条目出现的时间间隔等等。 –wikipedia 首先注意到，与泊松分布相比，其最大的差异就是指数分布是针对连续随机变量定义，即时间这个变量。时间必须是连续的。而泊松分布是针对随机事件发生次数定义的，发生次数是离散的。粗略地可以认为这两个分布之间有一种“倒数”的关系。 指数函数的概率密度函数: $$p(x;\\lambda)=\\lambda e^{-\\lambda x},x \\in [0,+\\infty)$$ 其中，$\\lambda &gt; 0$是该分布的一个参数，称为率参数(rate parameter)。即每单位时间内发生该事件的次数。读到这里，可能因为这个率参数被搞得一头雾水，容易跟泊松分布混淆。 指数分布的累积分布函数： $$p(x;\\lambda)=1- e^{-\\lambda x},x \\in [0,+\\infty)$$ 估计还是一头雾水😓，下面结合指数分布的概率密度曲线和累积分布曲线图，就稍微能理解下了（至少我是这么认为： 上述第二幅图像正是指数分布的累积分布函数图，对着图来看能更好的理解指数分布。 1.先看$\\lambda=1.0$这条曲线。关注到这条曲线上横坐标为1的点，其意义是1个单位时间该事件发生1次的概率。如果是横坐标为2的点，则其意义便是2个单位时间内该事件发生1次的概率。换个方法说，就是第k次该事件发生后隔2个单位时间发生第k+1次该事件的概率。 2.再看$\\lambda=1.5$这条曲线。与上述描述类似，先关注到这曲线上横坐标为1的点，其意义是1个单位时间内该事件发生1.5次的概率（次数居然是1.5次？？？理论上确实可以这么说，只是不好理解，如果换成整数次就可能更好理解）。如果是横坐标为2的点，其意义便是2个单位时间内该事件发生1.5次的概率。同样地，换个说法，也就是第k次该事件发生后隔2个单位时间该事件发生第k+1.5次的概率。 我觉得通过上述对图的表述，能进一步加深对指数分布的理解了。 结论首先，这两个分布最大的不同是，泊松分布是针对随机事件发生次数的定义的离散随机变量，而指数分布是针对随机事件发生的间隔时间定义的连续随机变量，这是二者最大的区别。切莫因为参数$\\lambda$把二者混淆了。","tags":[{"name":"probability theory","slug":"probability-theory","permalink":"https://xijunlee.github.io/tags/probability-theory/"}]},{"title":"有逼格的画图从gnuplot说起","date":"2016-12-24T12:29:04.000Z","path":"2016/12/24/2016-12-24-you-bi-ge-de-hua-tu-cong-gnuplotshuo-qi/","text":"有写论文需求的伙伴们，画图的时候肯定会被导师吐槽过“你这图画的真难看……”。如果不是在写学术论文，Excel就能解决大部分需求。但是，如果想画出印刷出版物品质的插图，还是得用到额外的工具。最常见的无非是用Matlab来画论文插图。但是，我还是有点嫌弃Matlab做出图片的配色和线条粗细（当然，这个可以调整，但每个人审美确实不同）。如果想画出大部分人都觉得精致的插图，该用什么好呢？其实，我之前一段时间是用的Python的一个库matlibplot,挺方便也挺好看的。但是后来，拜读隔壁大牛实验室IPADS的paper时，总觉得他们的插图很有逼格。这么一打听，才知道是用gnuplot画的。于是，我最近的一篇论文就开始全部用gnuplot作图了。以后应该是全面倒向gnuplot的怀抱。 此篇文章就简单记录下我使用gnuplot的过程，以后边学边update。首先，什么是gnuplot？ Gnuplot is a portable command-line driven graphing utility for Linux, OS/2, MS Windows, OSX, VMS, and many other platforms. The source code is copyrighted but freely distributed (i.e., you don’t have to pay for it). It was originally created to allow scientists and students to visualize mathematical functions and data interactively, but has grown to support many non-interactive uses such as web scripting. It is also used as a plotting engine by third-party applications like Octave. Gnuplot has been supported and under active development since 1986. 简单了说gnuplot就是一款跨多平台的，支持交互式的，开源的脚本画图语言。如果之前有过Python或Matlab经验的话，gnuplot上手就更快了。下面，给出一些gnuplot画图的demo。 安装gnuplot支持多平台，因此安装也是多种多样的，具体参见其下载页面，应当是比较简单的，尤其是在Windows下，其安装就是一路点到底。 一个demo for Windows因为我论文是在实验室的台式机(Windows)上写的。所以，下面的例子就以Windows下的gnuplot来讲解。 在我论文中，有个需求就是，将折线图和柱状图画在一个坐标系中，二者共用一个横坐标，而左边的纵坐标为柱状图的度量单位，右边的纵坐标为折线图的度量单位，如下图所示: 那么，该如何画这样的图呢？ 1. 准备好你的数据集gnuplot支持从.txt,.csv等诸多文件中读取数据。我推荐的方式是用额外的文件保存数据，画图的脚本从该文件中读取数据来进行画图。在我的实践中，我是用.txt来保存数据的，如下所示： 123456789101112131415161718letter.txt1 2.978431 35.85 35.95 35.32 5.886818 35.95 36.55 34.93 7.494 38.9 39.85 36.454 8.354836 39.5 41.65 36.25 9.533521 41.9 44.95 36.656 10.488704 46 48.1 38.957 10.809368 52.9 56.55 42.78 10.902275 59.75 66.9 479 10.927407 67.95 75.05 50.9510 10.933407 72.05 80.1 51.4511 10.936407 75.25 82.8 54.712 10.940407 78.65 84.7 56.6513 10.940407 82 89.45 59.3514 10.942407 83.5 89.45 64.715 10.942407 88 93.5 69.716 10.942407 86.65 95.35 69.75 其中，第一列是横坐标数，第二列是Entropy，第三到第五列是三个分类器的分类正确率。 2. 一个脚本demo我觉得学习写代码最快的方式就是直接读别人的代码，懂了后，然后就根据自己的需求改。那么下面，我就直接上绘图脚本的代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354set size ratio 0.8%设置输出图像的长宽比为0.8aqua = \"#00FFFF\"; azure = \"#F0FFFF\";aliceblue = \"#F0F8FF\"%这是我预设的三种颜色，根据rgb色彩原理set style fill solid 1.00 border 0set boxwidth 0.4 relative%设置柱状图中每条柱子的相对宽度set xlabel \"Attribute number\" font \"Verdana,15\"%设置x轴标签为\"Attribute number\" 字体和大小分别为\"Verdana\" 15set autoscaleset yrange [2:12];%设置左纵坐标轴取值范围为[2,12]set ylabel \"Entropy (/bit)\" font \"Verdana,15\";%设置左纵坐标轴标签为\"Entropy (/bit)\"set ytics 2 nomirror;%设置左纵坐标轴的刻度为2，并且不镜像复制到右边的纵坐标轴，默认情况下是左右纵坐标轴是一样的，但是我们这里的需求是两个纵坐标轴不一样set y2range [30:100];%设置右纵坐标轴的取值范围为[30,100]set y2label \"Accuracy (%)\" font \"Verdana,15\"%设置右纵坐标轴的标签为\"Accuracy (%)\"set y2tics 10 nomirror;%设置右纵坐标轴的刻度为10set key font \"Verdana,15\"%设置图例的字体和大小set key out horiz%设置图例在图像的外边，并且呈水平分布set key center top%设置图例拜访的位置set grid ytics%显示网格plot \"letter.txt\" using 2:xtic(1) title \"Entropy\" with boxes fs pattern 3 lc rgb aliceblue,\\ '' using 3 title \"SVM\" w lp lw 1.7 pt 2 ps 1.3 axes x1y2, \\ '' using 4 title \"DT\" w lp lw 1.7 pt 8 ps 1.3 axes x1y2, \\ '' using 5 title \"LDA\" w lp lw 1.7 pt 12 ps 1.3 axes x1y2%第48行代码的意思是：从letter.txt读取数据，使用第一列数据作为横坐标，坐标轴名为Entropy,并且柱状图，后面的参数是设置柱状图形状颜色等%而第49到第51行代码是来画折线图。这里我们以第49行的代码为例子来讲解：使用letter.txt中第三列数据绘制SVM正确率折线图，后面的参数是来设置折线的粗细和点的大小。注意到axes x1y2是指的是该折线图对应的坐标系是共用的横坐标轴和右纵坐标轴。 以上便是实现我画图需求的脚本。上述代码中，%之后的代码是注释，参照注释应该能明白每一步都是在做什么了吧。具体的参数细节，以后有空补上，或者读者们可以自行Google弄懂之~ 写完脚本后，保存为letter.plt文件即可。 3. 运行.plt脚本保存好后.plt脚本后，可以打开gnuplot交互命令窗口。点击change dir，切换到保存你当前脚本的那个文件夹，当然你也可以不切换，但在运行脚本时，就得写上脚本的绝对路径。切换好后，运行下面的代码: 1load 'letter.plt' 然后，你就能生成到一副看上去颇有逼格的图了。最后，你可以选择导出图片，gnuplot支持多种格式的图片输出，比如我就选择导出成.pdf。 好了，以上就是对gnuplot的一个简单粗暴的介绍，我也只是刚入门呐。在我个人看来，上述我提及的画图工具，他们制图精美程度的排序是gnuplot&gt;matlibplot=Matlab&gt;Excel。当然了，有的大神用Excel也能画出很高大上的图，但是前提是要花很多心思和时间在配色上。而gnuplot默认的配色和图像设置就能输出令大多数人赏心悦目的图片了。 当然了，最后还得补一句：插图的逼格是次要的，关键还得你paper确实有水平啊~","tags":[{"name":"academic plotting","slug":"academic-plotting","permalink":"https://xijunlee.github.io/tags/academic-plotting/"}]},{"title":"漫谈高维数据聚类(2):子空间聚类","date":"2016-12-22T01:46:37.000Z","path":"2016/12/22/2016-12-22-man-tan-gao-wei-shu-ju-ju-lei-2-zi-kong-jian-ju-lei/","text":"摘要如今处理高维数据的问题往往会有两座“大山”，分别是存储成本高和计算时间过长。显然，这是因为数据的高维数造成的。面对大规模的高维数据的聚类任务，传统的聚类算法有点hold不住了，正因此，子空间分割算法应运而生。 前面的一篇文章应该是解释清楚了啥是聚类，也安利了一个经典的聚类算法——K均值聚类。本篇开始正式介绍一些子空间聚类算法，以及这些聚类算法的应用实例。 1.什么是子空间聚类 给定一个n个样本构成的矩阵$X=[x_1, x_2, …, x_n]\\in R^{m*n},x_i \\in R^m$，并且已知这n个样本是分别来自k个子空间${S_i},i=1, …, k$。令${d_i&lt;m,i=1,…,k}$表示k个子空间的维度（其中$d_i$是未知的）。子空间聚类的目的是将这个n个样本正确地划归到各自所属的子空间中去，即将n个样本聚成k类，每一个类就是一个子空间。 从上图可以看到，总共有三个子空间，每个子空间上都有一些样本，位于同一个子空间内的样本就可以说是同一类的。每一个子空间有其相应的维数d,和一组基$[b_1,b_2,…,b_d]$，由这组基可以表示该子空间中任意一个向量。 2.稀疏表示模型和低秩表示模型目前，有四大类主流的求解子空间聚类问题的算法，分别是： （1）基于统计的方法：混合数据假设是从服从某一概率分布（如混合高斯分布）中抽取出的独立样本集，于是数据的分割问题就转化为一模型估计问题。代表性的工作有凝聚有损压缩[2]和随机抽样一致[1]； （2）基于矩阵分解的方法：将数据矩阵分解为一正交基矩阵和一低秩矩阵的乘积，从分解结果的结构来揭示聚类的特性。当子空间含有噪声和奇异值，或者独立子空间的假设不成立时，此类方法的效果不尽人意。代表性的工作有K子空间分割[4]； （3）基于代数的方法：可以处理子空间不是相互独立的情况，但计算量大，且对噪声和奇异值敏感。代表性的工作有Generalized PCA(GPCA)[3]； （4）基于谱聚类的方法：谱聚类算法是一种对高维数据进行聚类的技术。基于谱聚类的子空间分割算法先根据观测样本求得一个相似矩阵，然后对这个相似矩阵进行谱聚类获得最终的聚类结果。代表性的工作有稀疏子空间聚类[5]和低秩表示子空间聚类[6][7]。 而我要安利的是基于谱聚类的两个算法：稀疏表示子空间聚类算法和低秩表示子空间聚类算法，这两个算法都是比较简单和直观的，是子空间聚类研究这一块的基石性的算法，很多新算法都是在这两个算法的基础上加以改进而提出来的。当然，想要弄清楚这两个算法，还是需要一些简单的线性代数知识的。 稀疏表示(Sparse Representation)稀疏表示这一概念的提出，说到底还是受到压缩感知理论[8][9]的启发。该理论认为很多高维数据是冗余的，如果其具有可压缩性，那么可以只需要通过少量的采样便可恢复原始高维数据。更简单地说就是，许多高维数据是存在其低维表示的。 学过线性代数的都应该知道线性相关这一概念，即向量组$X=[x_1,x_2,…,x_n]$,其中$x_i$是$X$的列向量，若存在不全为0 的系数$a_1,a_2,…,a_n$，使得$a_1x_1+a_2x_2+…+a_nx_n=0$成立，则说$x_1,x_2,…,x_n$是线性相关的，如若$a_i$不等于零，那$x_i$就可以被其余向量线性表示，即$x_i=-(a_1x_1+a_2x2+…a{i-1}x{i-1}+a{i+1}x_{i+1}+…+a_nx_n)/a_i$。 有了以上两个认知，就可以理解稀疏表示了。在前面提到过位于同一个子空间中的样本，如果样本数足够多，那么某一个样本$x_i$是可以被与它位于同一个子空间中的其他样本线性表示的，而我们希望用尽量少的样本来表示$x_i$$，这就是稀疏表示的简单理解，用数学语言描述该模型如下： 给定一个n个样本构成的矩阵$X=[x_1,x_2,…,x_n]\\in R^{mn},xi\\in R^m$,其中每一列是一个样本，由$X$中d个样本构成一个“字典”$D=[x{i1},x{i2},…,x{id}]\\in R^{md}$,$D$中每一列成为原子。那么，每一个样本都可以表示成“字典”中原子的线性组合： $$X=DZ$$ 其中,$Z=[z_1,z_2,…,z_n]$是系数矩阵，$z_i$是样本$x_i$的“表示”。而字典$D$通常是过完备的，因为经常是选取全部样本作为字典，即$d=n$。因此，上市会有多个解。但是如给系数矩阵加上约束，则会有唯一解。稀疏表示即是要求系数矩阵$Z$是最稀疏的，即 $$\\min \\Arrowvert Z \\Arrowvert_1$$ $$s.t.\\quad X=DZ$$ 其中，$\\Arrowvert \\cdot\\Arrowvert_1$是求矩阵所有元素的绝对值的和。进一步，这个模型还可以加上噪声，即 $$\\min \\Arrowvert Z \\Arrowvert_1+\\lambda\\Arrowvert E\\Arrowvert_F$$ $$s.t.\\quad X=DZ+E$$ 低秩表示(Low-rank Representation)低秩表示模型和稀疏表示模型几乎一样，区别仅在于对系数矩阵的约束不同，在低秩表示中，它期望系数表示矩阵Z尽可能的低秩，用数学语言描述如下: $$ \\min rank(Z)$$ $$s.t.\\quad X=DZ$$ 其中,$rank(Z)$表示矩阵$Z$的秩。与$\\ell _0$范数一样，秩函数也具有离散组合性质，因此求解上式是一个NP难得。但是如果上式存在一个较低秩的解的话，秩优化问题可以被松弛为核范数最小化问题，即: $$\\min \\Arrowvert Z \\Arrowvert_*$$ $$s.t.\\quad X=DZ$$ 其中，$\\Arrowvert \\cdot \\Arrowvert_*$是矩阵的核范数。松弛的原理可以这么理解，一个矩阵的秩等于其非零奇异值的个数。那么矩阵的秩最小化等价于矩阵的奇异值非零个数尽量少，进一步可以松弛为矩阵的所有奇异值的和尽量小。 低秩表示模型是在稀疏表示模型之后提出来的，当然它比稀疏表示模型的性能更好，这是因为低秩表示模型中的核函数自带聚集属性，具体的原因我推荐论文[10]中的讲解（在其第五章中）。 ##上述两个模型的求解 求解这两个模型的方法有很多，有兴趣的朋友可以参阅论文[11]。 参考文献[1]Fischler M., Bolles R. RANSAC random sample consensus: a paradigm for model fitting with applications to image analysis and automated cartography. Journal of ACM, 1981, 24(6): 381–395. [2]Ma Y., Derksen H., Hong W., Wright J. Segmentation of multivariate mixed data via lossy coding and compression. IEEE Trans. Pattern Analysis and Machine Intelligence, 2007, 29(9): 1546–1562. [3]Vidal R., Ma Y., Sastry S. Generalized principal component analysis (GPCA). IEEE Trans. Pattern Analysis and Machine Intelligence, 2005, 27(12): 1–15. [4]Lu L., Vidal R. Combined central and subspace clustering on computer vision applications. In: Proc. 23rd Int’l Conf. Machine Learning (ICML), 2006, pp.593–600. [5] Elhamifar E, Vidal R. Sparse subspace clustering[J]. IEEE Conference on Computer Vision and Pattern Recognition, Cvpr, 2009:2790 - 2797. [6]G L, Z L, S Y, et al. Robust Recovery of Subspace Structures by LowRank Representation[J]. Pattern Analysis &amp; Machine Intelligence IEEE Transactions on, 2010, 35(1):171 - 184. [7]X G, K Z, D T, et al. Image SuperResolution With Sparse Neighbor Embedding[J]. IEEE Transactions on Image Processing, 2012, 21(7):3194 - 3205. [8]Donoho D L． Compressed sensing． IEEE Transactions on Information Theory,2006 52(4)：1289-1306． [9]Cand6s E．Compressive sampling．Proceedings of Proceedings of Inter-national Congress of Mathematicians，2006．1433-1452． [10] 卢参义. 基于稀疏表示的人脸分类与聚类[D]. 中国科学技术大学, 2012. DOI:10.7666/d.y2126052. [11]Lin Z, Chen M, Ma Y. The Augmented Lagrange Multiplier Method for Exact Recovery of Corrupted Low-Rank Matrices[J]. Eprint Arxiv, 2010.","tags":[{"name":"machine learning","slug":"machine-learning","permalink":"https://xijunlee.github.io/tags/machine-learning/"}]},{"title":"玩Hadoop中遇到的坑","date":"2016-12-21T02:46:30.000Z","path":"2016/12/21/2016-12-21-wan-hadoopzhong-yu-dao-de-keng/","text":"专门开一篇记录在玩Hadoop中遇到的坑，既给自己做个笔记，也为后来者做个提醒。 按照官方指南所给的步骤，一直执行到step 5之前都没什么问题，但是当执行到1$ bin/hdfs dfs -put etc/hadoop input 就报出如下错误:1put: 'input': No such file or directory 我的解决方案：在step 4中,1234$ bin/hdfs dfs -mkdir /user $ bin/hdfs dfs -mkdir /user/&lt;username&gt; ``` 这里就要注意了，```&lt;username&gt;```这里最好填你当前登录```ubuntu```的用户名(比如```root```)，因为后面使用 ```c$ bin/hdfs dfs -put etc/hadoop input 不指明绝对路径的话，Hadoop的相对路径默认的是从/home/[username]开始的，也就是/home/root/etc/hadoop, 如果创建文件夹时不是root的话，那自然找不到文件咯。所以，要么填当前操作ubuntu的用户名，要么乖乖地写全路径。","tags":[{"name":"distributed computing","slug":"distributed-computing","permalink":"https://xijunlee.github.io/tags/distributed-computing/"}]},{"title":"Markdown Test","date":"2016-12-20T01:33:38.000Z","path":"2016/12/20/2016-12-20-markdown-test/","text":"虽然博客搭好还是蛮快的，但是添加一些plugin，却花费了一些时间。对于我一个不会前端的人（只接触过html，js, etc.） 要我fix网页的bug还是挺为难我的。 作为一个以后的ML的从业者，那我的博文里就必须少不了各种公式，所以就必须借助MathJax.js帮助渲染公式。按照一系列的tutorial，安装好了MathJax.js，但是发现并不能work，花了两天解决了这个问题。其问题在于这个博客是通过https安全访问的，而MathJax.js的加载是通过http。所以在localhost访问时，Markdown.js能够顺利渲染LaTeX数学公式，而当真正deploy后，却无法访问。后面在script中将http改成了https才能正常加载o(╯□╰)o 好了，下面来测试下Markdown语法： 东川路吴彦祖 东川路吴彦祖 东川路吴彦祖东川路吴彦祖东川路吴彦祖这是一个外链接 [ ] 东川路吴彦祖 [x] 东川路吴彦祖 $$E=mc^2$$ 1234567@requires_authorizationclass SomeClass: pass if __name__ == '__main__': # A comment print 'hello world' 项目 价格 数量 计算机 \\$1600 5 手机 \\$12 12 管线 \\$1 234","tags":[{"name":"markdown","slug":"markdown","permalink":"https://xijunlee.github.io/tags/markdown/"}]},{"title":"漫谈高维数据聚类(1)","date":"2016-12-18T02:25:16.000Z","path":"2016/12/18/2016-12-18-man-tan-gao-wei-shu-ju-ju-lei-1/","text":"摘要：从高维数据中挖掘出有效信息并揭示其内在规律和本质，逐渐成为数据挖掘、机器学习、模式识别等领域的热点研究问题。其中，对于高维数据的聚类是一个最基本的，也是研究得最多的问题。传统的聚类算法，如K-means算法，已经无法胜任处理大规模高维数据聚类的任务。子空间分割算法正是为了解决高维数据聚类问题而被提出来，逐渐成为学术界研究的热点问题。 写在括号里的话：（其实这是我本科毕设的内容，当时做了两个月，觉得还比较有意思。花两三个月做毕设是有点多余的，期间很是拖沓。我觉得这个课题还是蛮有趣的，和实际应用联系得很紧密，所以我就来安利一下子空间聚类算法 (￣︶￣) 1.什么是高维数据？高维数据，顾名思义就是维数很高的数据（废话），像图像、视频这些最常见的数据就是高维数据，它们的维数至少都是上百维的。这么说不直观，我们来看下实际研究中是如何处理一张图像数据的。 图像是由不同的色彩构成的，我们可以将像素理解为图像的最小单位，像素是一个值，用来控制这么一个最小单位的色彩。最简单的图像就是灰度图，其实也就是黑白图片。不过黑色也分等级，比如白色可以理解为最浅的黑色，故白色定义为0，黑色的定义为255，其余不同程度的灰色介于0~255之间。 举个栗子，一张10*10的灰度图像就是长10个像素，宽10个像素，共100个像素构成的图像，每个像素值是在0~255之间。因此，一张图片实际等价于一个矩阵，如下图所示： 但是，现实生活中更为常见的是彩色图像。彩色图像相比灰度图要复杂些，其每个像素由R、G、B分量构成的图像，其中R、G、B是由不同的灰度级来描述的。以下公式能将一个彩色像素转换为灰度像素： 浮点算法：$Gray=R0.3+G0.59+B*0.11$； 整数方法：$Gray=(R30+G59+B*11)/100$； 移位方法：$Gray=(R76+G151+B*28)&gt;&gt;8$； 平均值法：$Gray=(R+G+B)/3$； 仅取绿色：$Gray=G$ 在实际应用中，我们的确是先把采集到的彩色图片转换成灰度图，得到灰度图的像素矩阵： 得到了像素矩阵后，我们才能开始一系列的数据处理任务。 前面那一节写了一大堆，只是为了描述我们实际应用中真正处理的数据对象长啥样。得到一副图像的灰度矩阵后，我们一般还会把这个矩阵拉成一个向量，即将矩阵的每一列接起来形成一个向量，我们称这样的向量是一个样本。 2.聚类 “将物理或抽象对象的集合分成由类似的对象组成的多个类的过程被称为聚类。” –wikipedia 举个栗子，如下图，共有三个人，每个人5张，总共15张正脸图像，聚类的目的是根据这些照片中的特征，将特征相似的图片聚到一起: 将上述15张图片正确地聚成三类，是聚类的终极目的： 一般地，我们将一张图片视为一个向量，具体的转换方法在第一节中有描述。聚类，用数学语言描述如下： 给定一个n个样本构成的矩阵$X=[x_1,x_2,…,x_n] \\in R^{m*n},x_i\\in R^m$，并且已知这n个样本是分别来自k个类别。聚类的目的是将这n个样本正确地划归到各自所述类别中去。 解决聚类问题的算法有很多：系统聚类法、有序样品聚类法，动态聚类法、K均值聚类法。我来安利一下K均值聚类算法好了。 2.1K均值聚类算法为简单起见，我就又举个栗子来说明这个算法吧。 如上图所示，总共有A,B,C,D,E五个样本，要将其聚成k=2类。其中，灰色点是类中心。K均值算法的流程如下： 1）类中心初始化。这里可以直接取任意k个样本作为初始类中心${C_i}(i=1,..,k)$，也可以随意取这些样本之外的k个点作为类中心${C_i}$； 2）计算每一个样本Pi到k个类中心${C_i}$的距离，将样本Pi划到与其距离最近的类中心${C_j}$所在的类中去，即若${C_j}$是到${P_i}$最近的类中心，则将${P_i}$归到第j类中去； 3）更新类中心。根据第2）步的聚类结果，计算新的类中心，较直接的方法是取该类中所有样本各坐标的均值作为新类中心的各坐标值。 4）重复步骤2），3），直到k个类中心不再发生变化，即得到最后的聚类结果； 步骤3）中是最简单的更新类中心的方法，但还有其他的求类中心的方法： 1、Minkowski Distance公式——λ可以随意取值： $$d{ij}=\\lambda\\sqrt{\\sum{k=1}^{n}|x{ik}-x{jk}|^\\lambda}$$ 2、Euclidean Distance公式——第一个公式λ=2的情况： $$d{ij}=\\sqrt{\\sum{k=1}^{n}(x{ik}-x{jk})^2}$$ 3、CityBlock Distance公式——第一个公式λ=1的情况： $$d{ij}=\\sum{k=1}^n|x{ik}-x{jk}|$$ 好了，以上就是对于聚类问题以及传统聚类算法的一个简单介绍，下一章中我将介绍针对高维数据聚类的子空间聚类算法。","tags":[{"name":"machine learning","slug":"machine-learning","permalink":"https://xijunlee.github.io/tags/machine-learning/"}]},{"title":"读书笔记之《历史的教训》","date":"2016-12-17T15:13:20.000Z","path":"2016/12/17/2016-12-17-du-shu-bi-ji-zhi-<<li-shi-de-jiao-xun->>/","text":"历来就喜欢读历史书籍，高中以前读的大多是中国古代史，到了大学以后，才以多种方式接触了欧洲近现代史和中国近现代史。但多多少少都觉得是以一种听故事的心态在读历史，从没思考过历史为什么会是这样子以及其中的规律，然而杜兰特这本精简的《历史的教训》简直是带我飞起来了，俯瞰过往的历史，原来这一切离散的历史都是有迹可循的。 这本书的作者——杜兰特夫妇是大有来头的，两人花了50年的时间写成了11卷的《世界文明史》，但因为这套书卷帙浩繁，比较学术，所以二人于1968年出了这套巨作的精简版《历史的教训》，方便一般读者阅读。因为作者是活跃于20世纪的人，因此他们的部分观点是有点过时和不客观的，大家去读了就知道。 下面，偷个懒，我就直接摘取书中让我停下来思考过的段落： 1、“一个人，无论他是如何光彩夺目或者见识广博，在他的有生之年，也不可能无所不知，总是能对他所在社会的习惯和礼俗做出明智的判断与取舍。因为这些习惯和礼俗，是无数代人在许多个世纪的历史长河中形成的智慧与经验的结晶。一个荷尔蒙旺盛的青年或许会问，为什么他不能充分享有性欲发泄的自由？假如他不遵守习俗、道德与法律的规范，在他足够成熟之前，还不明白性是一条充满烈火的欲河，必须处处设防，严加限制，约束自己，那么将会导致个人和团体的大混乱，并毁掉自己的一生。” ——摘自第五章 性格与历史 我的思考：其实这段简而言之就是“不听老人言吃亏在眼前”，我们现在确实是处在血气方刚的年纪，觉得不叛逆、墨守成规就是一点没有年轻人的朝气。但是，我们是否想过前人的这些规矩和制度为什么会留下来。举个栗子，古文明时期存在过多种婚姻制度，但为什么现代社会唯独推崇一夫一妻制？因为这是最有利于经济稳定和财产继承的婚姻制度，因此它留下来了。人类社会也同样适用适者生存的规则，现代社会推崇的价值观和制度不是某某领导人的意志，也不是上帝的神谕，而是长期社会发展优胜劣汰下来的人类经验之谈。当然，也不是要求我们每个人都要墨守成规，反正我觉得经过时间和社会认可的规律和制度都是值得年轻人遵循的。 2、“即使是持怀疑论的历史学家也对宗教保持谦卑的尊重，因为他看到了宗教在每一块土地、每一个时代，都发挥着似乎不可或缺的作用，宗教让社会最底层的人有了存在的意义和尊严；通过宗教的一些仪式，人间习俗变成与上帝的神圣关系，从而形成稳定的力量。宗教使穷人不会再去谋害富人（拿破仑语）。因为人生而不平等，所以注定我们有许多人经受贫穷和失败，对于失意的人而言，某种不可思议的超自然希望是替代绝望的唯一选择。摧毁了希望，阶级斗争就会愈演愈烈。天堂和乌托邦，就像一个井中的两个水桶：当一个下降时，另一个就会升上来；当宗教衰退时，共产主义就会兴起。 在我们这个时代以前的历史中，还找不到一个显著的例子表明，在没有宗教的帮助下，一个社会的道德生活也能成功地维持。法国、美国和其他一些国家，已经是他们的政府脱离了教会，但是他们仍然需要宗教在维数社会秩序方面给予帮助。只有少数几个共产主义国家，不仅已经与宗教脱离关系，并且还拒绝其援助。或许，这个实验在俄罗斯取得了明显而暂时的成功，在很大程度上归功于人们暂时将共产主义当成了人民的宗教，它取代了教会，成为了安慰与希望的供应者。如果社会主义政权不能消灭民众的相对贫穷，这个新的宗教就将失去它的狂热和效果，国家也许就会默许恢复超自然的信仰，以此来缓和不满。“只要有贫穷，就会有神灵。” ’ ——摘自第七章 宗教与历史 我的思考：嘘…… 3、“财富集中是自然的和不可避免的，可以借助暴力的或者是和平的部分再分配而得到周期性的缓解。就此而论，所有的经济史都是这个社会有机体缓慢的心脏跳动，财富的集中和强制再分配，便是它巨大的收缩与扩张运动。 ” ——摘自第八章 经济与历史 4、“对资本主义的恐惧，迫使社会主义不断扩大自由；而对社会主义的恐惧，则迫使资本主义不断增加平等。东方就是西方，西方就是东方，这一对双胞胎很快就会团聚。” ——摘自第九章 社会主义与历史 我的思考：虽然我们总是喊着要平等，要自由，其实仔细想想这二者是根本就是对立的嘛。社会从来就是不公平的，最集中的体现就是财富不均，如果要求人人平等，那么富人的自由势必受到限制。如果要求人人自由，那么穷人和富人会因为财富的差异造成享受不平等的自由权利。当代每个国家的政府无不都是在二者之中找平衡，一旦失衡，管你什么主义都势将倒闭。 5、“由于财富是一种生产和交换的秩序和过程，而不是囤积货物；是一种个人或机构的信托，而不是纸币或支票的内在价值。因此，暴力革命对财富所做的再分配，并不会多过对财富的损坏。对土地可以进行再分配，但是人们之间的天然不平等，很快就会产生新的占有和特权的不平等，形成新的少数人权力，他们的本能从本质上说和过去的少数一样。唯一真正的革命，是对心灵的启蒙和个性的提升；唯一真正的解放，是个人的解放；唯一真正的革命者，是哲学家和圣人。 如果教育机会平等能够建立起来，民主政治将会是真实和公平的。因为这才是它的口号背后至关重要的真理：虽然人们不能做到生而平等，但是教育和机会的获得会让他们越来越接近平等。民权不是去从政和行使权力，而是他们有选择每一种生活方式的权力，这种选择也可以检验一个人是否合适做官或者执政。” ——摘自第十章 政府与历史 我的思考：正因为生而不平等，所以人类社会才需要教育来弥补这种不平等。但是当代社会，教育资源和机会的多少却越来越与财富的多少挂钩，这个现象是在全球范围都有的，这到底是人为的还是社会发展必须的呢？ 6、“战争或冲突是万物之父，是各种观念、发明、制度和国家强有力的来源。和平只是一种不稳定的平衡，只能靠公认的霸权或势力均衡来维持。 ………… 英国在十九世纪很好地履行了保护西方文明免受外来威胁的职责，美国今天必须接过这一职责。新兴国家渴望通过一次工业革命，来获得经济的繁荣与军事力量的壮大，他们对苏联在政府管制下迅速工业化的过程印象深刻。也许最终西方资本主义国家会有更高的生产力，但是发展速度似乎较慢；一些新的执政者热衷于控制他们国家的资源与命脉，很可能被共产主义的宣传等活动所俘获。” ——摘自第十一章 历史与战争 我的思考：这一段的内容是与我以往所受到的教育相违背的，其中关于战争与和平的阐述既让我耳目一新，也是我思考了之后所认同的，但是这段中后半部分的内容就见仁见智了。 7、“在一个社会中，因为经济的发展产生了不平等，就会分化成两个阶层，一个是少数的文化精英，一个是多数的芸芸众生，他们十分不幸，因为天生的原因或者环境的关系，无法继承或者发展出高贵典雅的水准。随着这个多数的增长，它会对少数的文化起到拖累作用；它的谈吐、服饰、娱乐、感情、价值判断会向上扩散，多数内部的野蛮化是少数控制教育和经济机会所要付出的代价之一。” ——摘自第十二章 增长与衰退 我的思考：举个栗子，古罗马人的文化与制度是如此的令人赞叹，他们的文化是精致和伟大的。但是这些东西全部都建立在他们对周边蛮族的残酷剥削和统治之上。罗马周边的蛮族被逐渐罗马化了，但是是更多蛮族的习俗影响了罗马人，到了罗马后期，其军队中竟有四分之三是外族人。到最后，相对落后的日耳曼人竟征服了罗马，还是令人扼腕。 8、“从历史的过程中，我们认为，人类的本性并没有发生实质性的改变，所有的技术成就，都不得不被看成是用新方法完成就目标——取得财货，追求异性（或者同性），在竞争中取胜，发动战争。” ——摘自第十三章 真有进步吗？ 写在最后：我觉得这本书的每一章都值得大书特书，都值得深思。我也从来不认为读历史类书籍就立马会给人以启发，或者带来现实生中的好处。读历史，尤其是这种总结性质的历史书，给了我们一个机会从宏观的角度观察人类社会的运作，这往往是我们大陆学生所欠缺的，所以推荐此书，与诸君共勉。","tags":[{"name":"reading","slug":"reading","permalink":"https://xijunlee.github.io/tags/reading/"}]},{"title":"Blog Migration!","date":"2016-12-17T13:53:27.000Z","path":"2016/12/17/2016-12-17-mei-qian-liao-,yi-hou-yong-gitxie-bo-ke-ge/","text":"大四那段时间比较闲租了个服务器和域名，用WordPress搭了个博客，但由于研一是在太忙了，几乎没有管博客。然后到期了，嗯，租期到了，然后博客就被注销了。其实想想一年也写不了多少文字，也没多少人看，花钱来做这个确实性价比不高。 之前也确实早就知道octopress的大名，但当时嫌麻烦…… 大四的时候连命令行都不知道是什么，所以那会儿也就没想过用octopress。但是啊，人一旦窘迫后（不问爸妈要钱后），就开始知道生活中的柴米油盐酱醋茶什么都要钱。所以，就开始搬迁到git上了。github+octopress 免费而且不限容量。还能像黑客一样在命令行中写东西，逼格也上来了😊。 好了，这篇文章就是新搬家后博客的第一篇文章。往后的第一个工作就是以前那个博客上有点价值的东西搬过来（还好，当时我把内容存在了evernote上😶）","tags":[{"name":"dairy","slug":"dairy","permalink":"https://xijunlee.github.io/tags/dairy/"}]},{"title":"［iOS开发］推荐一个库，还是解决键盘隐藏问题，好用到飞上天！！","date":"2016-01-02T10:51:33.000Z","path":"2016/01/02/［iOS开发］推荐一个库，还是解决键盘隐藏问题，好用到飞上天！！/","text":"最近的这个项目，也是自己第一个iOS开发的项目，开发过程中最头疼的事情就是键盘弹出会遮挡到其他控件的问题。iOS不像android的键盘专门有一个隐藏键盘的按钮，因此给iOS开发者带来很多困扰。昨天刚刚转载了一个方法，但是今天遇到的一个问题就是：当键盘已弹出的情况下，点击另外一个uitextfield弹出一个新的view时（我设置了点击这个uitextfield是不会弹出键盘的，因此这个键盘是已经弹出的键盘），键盘遮挡住了view，试了很多方法都隐藏不了键盘。遇到问题，去git上搜搜总有解决办法，看到github上的一位开发者为iOS开发的模仿android键盘上隐藏键盘的按钮，这下是真的彻底解决了键盘隐藏问题吧！！！ 这个库就是hackiftekhar/IQKeyboardManager，效果图如下： 很实用的特性就是红框中标出的两个，一个是在有多个输入框下，可以通过左右键切换输入框，另一个是输入完成，点击done按钮，键盘就会隐藏（相信各位为键盘隐藏头疼的开发者从此不会再头疼了吧）。完整的特性可以去参看原作者的readme，我就稍微多说一下，如何使用这个库(这里针对objective-c，原作者对swift的使用方法说的相当详细了)，相当简单： 在你的Podfile文件中，添加pod ‘IQKeyboardManager’； 在shell中，执行pod install –verbose–no-repo-update命令，即导入该库到你的project中； 来到你的project的AppDelegate.m文件中，import IQKeyboardManager.h。然后在- (BOOL)application:(UIApplication )application didFinishLaunchingWithOptions:(NSDictionary )launchOptions {中键入以下这一行代码：[IQKeyboardManager sharedManager].enable = YES; 至此，就已经成功地将这个库应用到你的project中了，run一下，键盘真的服服帖帖地隐藏了耶，真是好用到飞起来！！！","tags":[{"name":"iOS development","slug":"iOS-development","permalink":"https://xijunlee.github.io/tags/iOS-development/"}]},{"title":"关于南京的记忆","date":"2015-10-07T10:44:42.000Z","path":"2015/10/07/关于南京的记忆/","text":"这半个月来，前半段时间折腾，后半段时间算是开始慢慢调整自己的生活节奏，适应学校的节奏。和德志、晟晟也进行多次了内容是除妹子之外的、思考人生的夜谈。到了这个年龄，逐渐开始有这么个认知：人，走到哪一步，是不是都是上天注定的呢？只不过是每个人的方式不同而已。努力和天赋，这两个东西，在我以前的认知里是完全两个概念。现在我意识到，一个人能持续不断的努力是不是也是一种天赋？导师、实验室的同学，都是很拼的人。小时候，幼稚地认为，只有笨蛋才会很努力。现在觉得，拼和努力都是为了自己心中的欲望，只不过每个人欲望不同，完全不需要在意别人的看法，别让自己淹没在大众之中。 好了，前一段和本文主题没有丝毫关系。前一个礼拜都在看文档，但是spark上的代码还是写不出。于是，溜出去，跑到南京找压抑玩耍去了。能和对胃口的人一起玩耍，是不怎么在乎去哪玩的。虽然，只有不到三天的行程，但还是让我对，南京，这座城市有了感觉。可能这里是很多旧朝的古都，有太多的英雄好汉、王侯将相、才子佳人的故事，也有过沉重的悲惨往事，因此，这座城是浮躁的、一切向GDP向钱看的当代社会另一种特别的存在。 最后一天，来到总统府，无数政权在这里建立、辉煌、坍塌，令人唏嘘。离我们最近的，就是KMT政府，人们都是喜欢厚古薄今的，我也如此（不能多说了，怕被查水表）。但是，当我看到无数游客踩过前总统，前政府的办公楼，就心有慨叹。这里本该是个肃穆的地方，即使是输掉江山的前政权，也是值得我们尊重的。就我个人看来，不论哪个政权取得了最后的胜利，都还是须对前政权留有一份尊重，这是文明和法理的传承。 常凯申，虽然能力和人格魅力上是比不上我们的毛主席，但是他是一个值得令我们尊敬的民族主义者和民族权益的捍卫者，向您敬礼。 南京，还会再来的！ 以上 2015-10-7, 上海","tags":[{"name":"dairy","slug":"dairy","permalink":"https://xijunlee.github.io/tags/dairy/"}]},{"title":"算法导论学习之红黑树(2)","date":"2015-07-22T10:31:04.000Z","path":"2015/07/22/算法导论学习之红黑树-2/","text":"写在前面的话这一章具体介绍红黑树的删除操作，以及我对删除一系列操作的理解。 话不多说，我先直接给出算导上关于删除操作的伪代码（这伪代码几乎就可以当作实现代码了，不过还是要搞懂原理） 红黑树的删除操作删除操作伪代码123456789101112131415161718RB-DELETE(T,z) if left[z] == nil[T] || right[z] == nil[T] then y &lt;- z else y &lt;- TREE-SUCCESOR(z) if left[y] != nil[T] then x &lt;- left[y] else x &lt;- right[y] p[x] &lt;- p[y] if p[y] == nil[T] then root[T] &lt;- x else if y == left[p[y]] then left[p[y]] &lt;- x else right[p[y]] &lt;- x if y != z then key[z] &lt;- key[y] copy y’s satellite data into z if color[y] == BLACK then RB-DELETE-FIXUP(T,z) 可以从上述伪代码发现，红黑树的删除操作和普通二叉树操作差不多，但因为红黑树的性质，当如果删除的节点是一个黑节点时，则有可能违反某些性质（用脚趾头想最可能违反的性质就是性质5）：某个节点到其叶子节点所有路径上的包含相同的黑节点数），那么就需要调用 RB-DELETE-FIXUP(T,z)来修正。为什么不要讨论删除的节点是红节点的情况呢？如果这棵树先前就是一棵标准的红黑树的话，那么它就满足所有的红黑性质，删除一个红色节点，是不会违反任何一条性质的。 下面先给出RB-DELETE-FIXUP(T,z)的伪代码 1234567891011121314151617181920212223RB-DELETE-FIXUP(T,z)的伪代码： while x != root[T] &amp;&amp; color[x] == BLACK do if x == left[p[x]] then w &lt;- right[p[x]] if color[w] == RED then color[w] &lt;- BLACK //case 1 color[p[x]] &lt;- RED //case 1 LEFT-ROTATE(T,p[x]) //case 1 w &lt;- right[p[x]] //case 1 if color[left[w]] == BLACK &amp;&amp; color[right[w]] == BLACK then color[w] &lt;- RED //case 2 x &lt;- p[x] //case 2 else if color[right[w]] == BLACK then color[left[w]] &lt;- BLACK //case 3 color[w] &lt;- RED //case 3 RIGHT-ROTATE(T,w) //case 3 w &lt;- right[p[x]] //case 3 color[w] &lt;- color[p[x]] //case 4 color[p[x]] &lt;- BLACK //case 4 color[right[w]] &lt;- BLACK //case 4 LEFT-ROTATE(T,p[x]) //case 4 x&lt;-root //case 4 else (same as then clause with “right” and “left” exchange) 可能初看这么一大堆伪代码，谁看谁都会头晕。先思考下删除一个黑节点会违反哪些性质呢？ * 如果y原来是根节点，那么y的一个红孩儿x可能成为新根，那么就违反了根节点必须是黑色的性质； * 如果x和p[y]都是红色的，那么删除了黑节点y后，那就违反了两个红节点不能相邻的性质； * 因为删除了一个黑色节点y，那么在包含节点y的路径上就少了一个黑节点，就违反了性质5） 算法导论书上fix上述可能违反的性质的基本思路其实也很简单：因为删除的是一个黑节点，其黑色的删除是一定会违反性质5）的，那么就假想被删结点y的儿子节点x具有一层额外的黑色，如果x原本是红节点的话，就把x节点染成黑色，如果x不是红节点的话，就沿着x往上升，找到一颗红节点并把它染成黑色；如果一直往上升，直到根节点都没有找到红节点的话，那就可以把这额外的黑色给“挤”出去。要完成上述两个想法，需要一定的旋转和颜色改变。下面来讨论具体的八种可能违反红黑性质的情况。 图1 删除操作的四种情况，其余四种是这四种的对偶 需要考虑的有八种情况，但是其中四种与另外四种是相互对称的，因此只需要详细讲其中四种的操作即可： x的兄弟w是红色的；处理方法：因为能进入到循环内，所以x一定是黑的。并且其兄弟w是红的，所以x的父亲一定是红的，于是将w与p[x]的颜色互换，然后对p[x]做左旋。x的兄弟w就变成节点D，是黑色的，于是将情况1转换成了情况2。 x的兄弟w是黑色的，并且w的两个儿子都是黑色的。处理方法：将w涂成红色的，并将x指向原来x的父亲节点。注意到，只有在这个情况下才会使得指针上升。 x的兄弟w是黑色的，但w的左孩子是红色的，w的右孩子是黑的。处理方法：将w与其左孩子颜色互换，然后对w做右旋，x的新兄弟变成节点C。这时，x的兄弟w变成黑色，而其右孩子变成了红色，将情况3转换成了情况4. x的兄弟w是黑色的，且w的右孩子是红色的。处理方法：这种情况是终极情况，只需要将p[x]和w的颜色互换，并将w的红孩儿染成黑色的，然后对p[x]做左旋，最后将x指向整棵树的根，即可退出while循环。 总结：因为删除的是一颗黑节点，黑节点的减少，势必会违背性质5。因此就要想方设法将这额外的黑色转嫁给树中某颗红节点。可以看到，情况1和情况3并没有在局部新增黑色的节点，这两种情况的作用只不过是将它们转化为情况2和情况4。而情况2是将x所在这一层的所有黑色减少一次，将这个黑色转接到其父亲那一层去。情况4则更简单，找到x兄弟w的一个红孩儿，把它染成黑色，就结束了这一路寻找红节点的旅程。 以下是四种情况的转化关系： 图2 四种情况的转化关系","tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://xijunlee.github.io/tags/algorithm/"}]},{"title":"算法导论学习之红黑树(1)","date":"2015-07-20T10:24:33.000Z","path":"2015/07/20/算法导论学习之红黑树-1/","text":"写在前面的话花了三天时间，将将实现了红黑树算法，但还是不能裸写红黑树，起码要看着算导书上的示意图::&gt;_&lt;:: 整个算法确实算比较复杂的，实现代码比普通二叉树多一倍多，但换来的是效率上的提升。废话不多说，总结一下学习心得（基本的细节不会提到，因为可以去翻书，我只写出对书中个别知识点的理解和总结），方便日后会看红黑树时，能立马回忆起来。 红黑树的性质 每个节点要么是红的， 要么是黑的； 根节点是黑的； 每个叶节点（NIL）是黑的； 如果一个节点是红的，那么它的两个儿子是黑的； 对每个节点，从该节点到其子孙节点的所有路径上包含数目相同的黑节点。 以上四条性质都很好理解，唯独就是第五条不好理解，我觉得是翻译的不好。如果不亲自去实现一遍这个算法，对第五条性质中的“子孙节点”的理解是会有歧义的。比如，我初次看到这条性质的时候，我将该节点的子孙节点理解成为该节点的儿子节点+孙子节点+曾孙子节点+……+叶节点，汉语中确实是这么个意思嘛，但实际上是指沿着该节点下去的能达到的所有叶子节点。 图1 一棵标准的红黑树 如图所示，这是一棵标准的红黑树。针对性质5），我们从图中根节点26出发，很容易验证到达其叶子节点nil[T]的所有路径中经过的黑节点数都是4（当然包括它本身）。再拿节点21做例子，从节点21出发到达叶子节点的所有路径中经过的黑节点数都是3。这才是性质5）想要表达的意思，因此，我将性质5）转述成了如下：性质5）对于每个节点，从该节点到叶子节点nil[T]的所有路径上包含相同数目的黑节点。有了对上述五条性质的正确理解，才能搞得懂后面那些操作算法，因为这些算法的正确性需要有这些性质做保证。 局部旋转 图2 旋转操作 旋转操作还是很简单的，所以不去赘述其细节，但在具体实现的时候要注意两点： 节点之间的连接关系的建立与删除最好是成对地去处理； 若旋转前的父节点x是整棵树的根节点，旋转之后，要记得将树的根节点置为y。 插入操作先给出算法导论书上的伪代码： 123456789101112131415161718RB-INSERT(T,z)伪代码 y &lt;- nil[T] x &lt;- root[T] while x != nil[T] y &lt;- x if key[x] &gt; key[z] then x &lt;- left[x] else x&lt;- right[x] p[z] &lt;- y if y == nil[T] then root[T] &lt;- z else if key[z] &lt; key[y] then left[y] &lt;- z else right[y] &lt;- z left[z] &lt;- nil[T] right[z] &lt;- nil[T] color[z] &lt;- RED RB-INSERT-FIXUP(T,z) 从上述伪代码可以看出，红黑树的插入操作与普通二叉树的插入操作的差别很小，我们可以注意到插入的新节点的颜色居然是红色，为什么是红色呢？其实很容易想得通，如果插入的新节点就是黑色的话，那么会改变某个节点的黑高度，因此违反了性质5），往往涉及到黑节点的处理都会比较复杂。因此算导选择插入的新节点一开始就将它设置为红色的，但这样子也可能违反性质2）、4），因此需要有一个辅助程序RB-INSERT-FIXUP来修补可能违反的性质。 RB-INSERT-FIXUP修补可能违反的性质4），z指向插入的红色节点，因为违反了性质4），所以p[z]也是红的。可以将违反性质4）的情况归结为三种（其实，不止三种，是六种，另外三种可以通过对称关系得到。） 1234567891011121314151617RB-INSERT-FIXUP(T,z)伪代码 while color[p[z]] == RED if p[z] == left[p[p[z]] then y &lt;- right[p[p[z]] if color[y] == RED //case1 then color[p[z]] &lt;- BLACK //case1 color[y] &lt;- BLACK //case1 color[p[p[z]] &lt;- RED //case1 z &lt;- p[p[z]] //case1 else if z == right[p[z]] //case2 then z &lt;- p[z] //case2 LEFT-ROTATE(T,z) //case2 color[p[z]] &lt;- BLACK //case 3 color[p[p[z]] &lt;- RED //case 3 RIGHT-ROTATE(T,p[p[z]]) //case 3 else (same as then clause with “right” and “lefet” exchange) color[root[T]] &lt;- BLACK 图3 插入操作中可能遇到的三种情况 z的叔叔y是红色的。处理方法：很简单，将z的祖父染成红色，将其父亲和叔父染成黑色，这样就解决了z的红色与其父亲也是红色的冲突。（那么其祖父先前就会是黑色的吗？答案是一定的，因为z的父亲和叔叔都是红色的，而未加入红节点z之前该树是满足红黑性质的，因此z的祖父一定是黑色的，如果z的祖父也是红的话，那么就与z父亲是红色的冲突了。）z指向其原来祖父，这样指针沿着树上升了两层。并且所有情况中，只有情况1会使得指针z上升两层。 z的叔叔y是黑色的，z是其父亲的右孩子。处理方法：将z的父亲右旋即可，z指向原先z的父亲。经过旋转变换后，现在的z是其父亲的左儿子，并且它的叔叔是黑色的，那么情况2就转换为了情况3。 z的叔叔y是黑色的，z是其父亲的左孩子。处理方法：通过情况1或者情况2都可能进到情况3。因为在这个情况下，z及其父亲p[z]都是红色。故先将其父亲p[z]染成黑色，将其祖父p[p[z]]染成红色，然后对祖父节点p[p[z]]做右旋。 其余的三种情况与上述三种情况是相互对称的。上述三种情况的转化关系如下： 最后，值得注意的是退出while循环时，需要置根节点的颜色为黑色。因为while循环条件是z的父亲p[z]为红色的，当z指向树的根时，z的父亲是nil[T]为黑色，故会退出循环，但是z的颜色为红色，因此需要置其颜色为黑色，这样就不违反性质2）了。","tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://xijunlee.github.io/tags/algorithm/"}]},{"title":"算法导论学习之二叉查找树的删除操作","date":"2015-07-14T10:13:48.000Z","path":"2015/07/14/算法导论学习之二叉查找树的删除操作/","text":"写在前面的话虽然二叉树很简单，但是其中的删除操作还是有些麻烦的。看完算导关于本节的内容后，动手实现了一遍，发现自己写的代码虽然功能能实现，但是代码很丑，究其原因就是我并没有仔细总结删除操作中三种情况的共性，所以自己写的代码有很多冗余。回头看算导上的伪代码，发现自己还是太naive，认真总结了下三种情形的共同特点，又重新有了收获，以后也可以裸写二叉树的删除操作了。 在本篇中，我只会阐述我对于删除操作的理解，因为前面的遍历、插入、查找等操作都十分简单易懂易实现，当然还有一个前提是需要对二叉树的基本性质有起码的理解。 图1 二叉树删除操作的三种情况:a)被删除节点z没有任何子女 b)被删节点z有一个子女 c)被删节点z有两个子女 总共有三种情况： 被删除节点z没有任何子女。是最简单的情况，将z父节点12的儿子指针置为null，再free掉节点z就好; 被删节点z有且只有有一个子女。这个情况稍微麻烦点，但说起来比较容易，将节点z的父节点15和其唯一子节点20连接起来就好，然后free掉节点z就好; 被删节点z有两个子女。这个是最复杂的，但是其基本思想还是没变，将第三种情况转化为第二种情况处理即可。那么怎么做呢？解决方法就是去找z的后继（后继是什么？就是比节点z中关键字5大的所有节点中最小的那个，说起来很拗口是吧，就是图中关键字为6的节点y）。要删除有两个子女的节点z，就去找它的后继节点y，它的后继节点y能保证只有一个右儿子（为什么？如果它的后继节点有左儿子，那么节点y就不可能是z的后继节点。算导书上p155 练习 12.2-5有要求证明，不懂的可以稍微思考下）。基于上述事实，我们找到了z的后继节点y，那么就已经将情况3转化为了情况2了，接下来要做的操作就是将y的父节点10与y的子节点7连起来。这时还没做完，因为z才是待删除的节点，我们要将节点z出的关键字替换为节点y的关键字，如图中所示。然后free掉节点y。 以上就是对三种情形的处理方法，可以涵盖所有的节点删除可能出现的情形。从上面可以看到，情况2是一般形式，情况1是情况2的最简单形式，情况3是情况2的最复杂形式，但是都可以转化成情况2。有了以上认识，我们就可以看清楚算法导论上伪代码的意图了，也方便我们以后裸写二叉树的删除操作了。下面我解释下伪代码是如何具体实现这些操作的。 第2~4行，是判断待删除节点是什么类型的。如果是有且只有一个子节点或没有子节点的节点，那么y=z。若是有两个子节点的节点，那么就去找它的后继，因此y=TREE-SUCCESSOR(z)，（真正要删除的节点是y）； 第5~7行，是获得节点y的子节点x。因为节点y能保证一定是只有一个儿子的（或者没有儿子，也就是说x==null）； 第8~14行，便是将节点y的子节点和其父节点“连接起来”。 第15~16行，是替换关键字的操作。因为y有可能是z的后继，所以要将节点z的关键字替换为节点y的关键字。最后，删除节点y即可。 finally,贴上我利用c++实现的一系列二叉树操作的代码，请见笑了╭(′▽`)╯： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172// 二叉查找树.cpp : 定义控制台应用程序的入口点。//#include \"stdafx.h\"#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;iostream&gt;using namespace std;typedef struct dataType&#123; int key; dataType *p; dataType *left; dataType *right;&#125;node;node *root;void INORDER_TREE_WALK(node *x)//中序遍历&#123; if (x != NULL) &#123; INORDER_TREE_WALK(x-&gt;left); cout &lt;&lt; x-&gt;key &lt;&lt; endl; INORDER_TREE_WALK(x-&gt;right); &#125; return;&#125;node* TREE_SEARCH(node *x, int k)&#123; if (x == NULL || k == x-&gt;key) return x; else &#123; if (k &lt; x-&gt;key) x = x-&gt;left; else x = x-&gt;right; return TREE_SEARCH(x, k); &#125;&#125;node* TREE_MAXIMUM(node *x)&#123; while (x-&gt;right != NULL) &#123; x = x-&gt;right; &#125; return x;&#125;node* TREE_MINIMUM(node *x)&#123; while (x-&gt;left != NULL) &#123; x = x-&gt;left; &#125; return x;&#125;node* TREE_SUCCESSOR(node *x)&#123; if (x-&gt;right != NULL) return TREE_MINIMUM(x-&gt;right); node* y = x-&gt;p; while (y!=NULL &amp;&amp; y-&gt;right==x) &#123; x = y; y = y-&gt;p; &#125; return y;&#125;node* TREE_PREDECESSOR(node *x)&#123; if (x-&gt;left != NULL) return TREE_MAXIMUM(x-&gt;left); node* y = x-&gt;p; while (y != NULL &amp;&amp; y-&gt;left == x) &#123; x = y; y = y-&gt;p; &#125; return y;&#125;void TREE_INSERT(node *T, node *z)&#123; node *y = NULL; node *x = T; while (x != NULL) &#123; y = x; if (z-&gt;key &lt; x-&gt;key) x = x-&gt;left; else x = x-&gt;right; &#125; z-&gt;p = y; if (y == NULL)//则新插入的节点作为树根 T = z; else &#123; if (y-&gt;key &gt; z-&gt;key) y-&gt;left = z; else y-&gt;right = z; &#125;&#125;void TREE_DELETE(node *T, node *z)&#123; node *y,*x; if (z-&gt;left == NULL || z-&gt;right == NULL) y = z; else y = TREE_SUCCESSOR(z); if (y-&gt;left != NULL) x = y-&gt;left; else x = y-&gt;right; if (x != NULL) x-&gt;p = y-&gt;p; if (y-&gt;p == NULL) &#123; T = x; &#125; else &#123; if (y == y-&gt;p-&gt;left) y-&gt;p-&gt;left = x; else y-&gt;p-&gt;right = x; &#125; if (y != z) z-&gt;key = y-&gt;key; delete y;&#125;node* ALLOCATE_NODE(int k)&#123; node *tmp = new node; tmp-&gt;key = k; tmp-&gt;p = NULL; tmp-&gt;left = NULL; tmp-&gt;right = NULL; return tmp;&#125;int _tmain(int argc, _TCHAR* argv[])&#123; int a[] = &#123; 15, 5, 3, 16, 20, 12, 10, 6, 7, 13, 18, 23 &#125;; root = ALLOCATE_NODE(15); for (int i = 1; i &lt; 12; i++) &#123; TREE_INSERT(root, ALLOCATE_NODE(a[i])); &#125; INORDER_TREE_WALK(root); /* cout &lt;&lt; \"the MAXIMUM in this tree\" &lt;&lt; TREE_MAXIMUM(root)-&gt;key &lt;&lt; endl; cout &lt;&lt; \"the MINIMUM in this tree\" &lt;&lt; TREE_MINIMUM(root)-&gt;key &lt;&lt; endl; cout &lt;&lt; TREE_PREDECESSOR(TREE_SEARCH(root, 15))-&gt;key &lt;&lt; endl; cout &lt;&lt; TREE_SUCCESSOR(TREE_SEARCH(root, 15))-&gt;key &lt;&lt; endl;*/ node *tmp = TREE_SEARCH(root, 18); TREE_DELETE(root, tmp); cout &lt;&lt; \"After delete the node 3:\" &lt;&lt; endl; INORDER_TREE_WALK(root); return 0;&#125;","tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://xijunlee.github.io/tags/algorithm/"}]}]